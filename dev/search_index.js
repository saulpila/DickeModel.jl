var documenterSearchIndex = {"docs":
[{"location":"TruncatedWignerApproximationExamples/#Examples-for-TrucatedWingerApproximation","page":"Truncated Wigner Approximation","title":"Examples for TrucatedWingerApproximation","text":"","category":"section"},{"location":"TruncatedWignerApproximationExamples/","page":"Truncated Wigner Approximation","title":"Truncated Wigner Approximation","text":"push!(LOAD_PATH,\"../../src\")\non_github=get(ENV, \"CI\", nothing) == \"true\"\non_github=false\nusing Dicke","category":"page"},{"location":"TruncatedWignerApproximationExamples/#Classical-evolution-of-coherent-states","page":"Truncated Wigner Approximation","title":"Classical evolution of coherent states","text":"","category":"section"},{"location":"TruncatedWignerApproximationExamples/","page":"Truncated Wigner Approximation","title":"Truncated Wigner Approximation","text":"The module Dicke.TruncatedWignerApproximation is a very powerful tool to study the classical evolution of distributions in the phase space.","category":"page"},{"location":"TruncatedWignerApproximationExamples/","page":"Truncated Wigner Approximation","title":"Truncated Wigner Approximation","text":"Let us load the module Dicke.TruncatedWignerApproximation, together with Distributed which allows paralelization.  ","category":"page"},{"location":"TruncatedWignerApproximationExamples/","page":"Truncated Wigner Approximation","title":"Truncated Wigner Approximation","text":"using Distributed\nusing Plots,Plots.PlotMeasures\nusing Dicke,Dicke.TruncatedWignerApproximation, Dicke.ClassicalDicke\nif false #hide\naddprocs(2) #we add 2 workers. Add as many as there are cores in your computer.\n@everywhere using Dicke,Dicke.TruncatedWignerApproximation\nend #hide","category":"page"},{"location":"TruncatedWignerApproximationExamples/","page":"Truncated Wigner Approximation","title":"Truncated Wigner Approximation","text":"The functions from Dicke.TruncatedWignerApproximation will make use of all the available workers.","category":"page"},{"location":"TruncatedWignerApproximationExamples/","page":"Truncated Wigner Approximation","title":"Truncated Wigner Approximation","text":"warning: Warning\nThe line @everywhere using Dicke, Dicke.TruncatedWignerApproximationis necessary to load  Dicke.TruncatedWignerApproximation in all workers. You will get errors if you omit it.","category":"page"},{"location":"TruncatedWignerApproximationExamples/","page":"Truncated Wigner Approximation","title":"Truncated Wigner Approximation","text":"For our first example, let us consider the Wigner function of a coherent state, evolve it classically using the truncated Wigner approximation, and then look at  the expected value of the Weyl symbol of the observable hatj_z=hatJ_zj in time with  TruncatedWignerApproximation.average. Note the usage of Weyl.Jz.","category":"page"},{"location":"TruncatedWignerApproximationExamples/","page":"Truncated Wigner Approximation","title":"Truncated Wigner Approximation","text":"system = ClassicalDickeSystem(Ï‰=1.0, Î³=1.0, Ï‰â‚€=1.0)\nx = Point(system, Q=1, P=1, p=0, Ïµ=0.5)\nj = 300\nW = coherent_Wigner_HWxSU2(x,j=j)\njz = Weyl.Jz(j)/j \ntimes = 0:0.05:40\nif !on_github  times=0:1:4 end #hide\n\nN = 20000\nif !on_github N=200 end #hide\njz_average=average(system;observable=jz, distribution=W, N = N, ts=times)\nplot(times,jz_average, xlabel=\"time\", \n    ylabel=\"jz\",key=false,ylim=(-1,1), size=(700,350))\nsavefig(\"average_jz_TWA.svg\");nothing #hide","category":"page"},{"location":"TruncatedWignerApproximationExamples/","page":"Truncated Wigner Approximation","title":"Truncated Wigner Approximation","text":"(Image: )","category":"page"},{"location":"TruncatedWignerApproximationExamples/","page":"Truncated Wigner Approximation","title":"Truncated Wigner Approximation","text":"Okay, but we can do more. Let's see how the whole distribution of j_z evolves classically using TruncatedWignerApproximation.calculate_distribution.","category":"page"},{"location":"TruncatedWignerApproximationExamples/","page":"Truncated Wigner Approximation","title":"Truncated Wigner Approximation","text":"y_axis_values = -1.1:0.01:1.1\nmatrix = calculate_distribution(system; distribution=W, N = N,\n    x=:t,  ts=times,\n    y=jz, ys=y_axis_values)\nheatmap(times, y_axis_values, matrix,\n    size=(700,350), color=cgrad(:gist_heat, rev=true),\n    xlabel=\"time\", ylabel=\"jz\")\nsavefig(\"distribution_jz_TWA.svg\");nothing #hide","category":"page"},{"location":"TruncatedWignerApproximationExamples/","page":"Truncated Wigner Approximation","title":"Truncated Wigner Approximation","text":"(Image: )","category":"page"},{"location":"TruncatedWignerApproximationExamples/","page":"Truncated Wigner Approximation","title":"Truncated Wigner Approximation","text":"We can chain several computations using TruncatedWignerApproximation.mcs_chain.  For example, let's see the evolution of q and p for the same coherent state evolving in time, along with the time-averaged distribution in the plane qp.","category":"page"},{"location":"TruncatedWignerApproximationExamples/","page":"Truncated Wigner Approximation","title":"Truncated Wigner Approximation","text":"qs=-4.2:0.02:4.2\nps=-2.4:0.02:2.4\nif !on_github  qs=-4.2:0.5:4.2;ps=-2.4:0.5:2.4 end #hide\nN = 50000\nif !on_github N=200 end #hide\n\nmcs=mcs_chain(\n    mcs_for_distributions(\n        system; N = N, \n        distribution=W,\n        y=:t,  ts=times,\n        x=:q, xs=qs),\n    mcs_for_distributions(\n            system; N = N,\n            distribution=W,\n            y=:p, ys=ps,\n            x=:t,  ts=times),\n    mcs_for_distributions(\n        system; N = N,\n        distribution=W,\n        x=:q,  xs=qs,\n        y=:p, ys=ps,ts=times)\n)\nmatrix_q_vs_t,matrix_t_vs_p,matrix_q_vs_p = monte_carlo_integrate(system,\n    mcs;ts=times,N=N,distribution=W,tolerate_errors=false)\n    \n    \nplot(heatmap(qs,times, matrix_q_vs_t,\n        color=cgrad(:gist_heat, rev=true),\n        ylabel=\"time\", xlabel=\"q\", xmirror =true, \n        ymirror =true, bottom_margin = -15mm),\n    heatmap(times,ps, matrix_t_vs_p,\n        color=cgrad(:gist_heat, rev=true),\n        xlabel=\"time\", ylabel=\"p\", right_margin = -15mm),\n    heatmap(qs,ps, matrix_q_vs_p,\n        color=cgrad(:gist_heat, rev=true),\n        ticks=:none,size=(400,400),margin = -15mm),\n    layout=(@layout [_ Â°; \n                     Â° Â°]), \n    color=cgrad(:gist_heat, rev=true),\n    size=(800,800),colorbar=:none,link=:both)\nsavefig(\"distribution_qptime_TWA.svg\");nothing #hide.","category":"page"},{"location":"TruncatedWignerApproximationExamples/","page":"Truncated Wigner Approximation","title":"Truncated Wigner Approximation","text":"(Image: )","category":"page"},{"location":"TruncatedWignerApproximationExamples/","page":"Truncated Wigner Approximation","title":"Truncated Wigner Approximation","text":"The function calculate_distribution can even animate the evolution (with a little help from the wonderful @animate from Plots).","category":"page"},{"location":"TruncatedWignerApproximationExamples/","page":"Truncated Wigner Approximation","title":"Truncated Wigner Approximation","text":"N = 1000000\ntimes = 0:0.1:40\nif !on_github N=200 end #hide\nif !on_github times=0:1 end #hide\n\nmatrices = calculate_distribution(system; distribution=W, N = N,\n    x=:q, y=:p,xs=qs, ys=ps, ts=times, animate=true, maxNBatch=200000);\nanimation=@animate for mat in matrices\n    heatmap(qs, ps, mat,\n        color = cgrad(:gist_heat, rev=true), size=(600,600), \n        xlabel=\"q\", ylabel=\"p\", key=false)\nend\nmp4(animation,\n    \"animation_of_evolution.mp4\",\n    show_msg=false, #hide\n    fps=30)\nnothing; #hide","category":"page"},{"location":"TruncatedWignerApproximationExamples/","page":"Truncated Wigner Approximation","title":"Truncated Wigner Approximation","text":"(Image: )","category":"page"},{"location":"TruncatedWignerApproximationExamples/","page":"Truncated Wigner Approximation","title":"Truncated Wigner Approximation","text":"note: Note\nComputing animations with calculate_distribution(..., animate = true, ...) may need a lot of RAM. You can estimate the maximum amount of RAM needed using the shorthand formula  (text of workers) times (textlength of  xs )times (textlength of  ys )times (textlength of  ts ) times (64 text bits).But this number would only be reached if trajectories filled all of the matrices in all of the workers at all the timesteps. You may stay much below this number by passing maxNBatch to calculate_distribution (or to  monte_carlo_integrate). This parameter limits the number of trajectories that are calculated in batch in each  worker. Between batches, data is flushed to the main worker, which takes time, but liberates RAM.  If generating the animation is filling up your RAM, try to decrease maxNBatch.","category":"page"},{"location":"TruncatedWignerApproximationExamples/#Fidelity-out-of-time-order-correlator-(FOTOC)","page":"Truncated Wigner Approximation","title":"Fidelity out-of-time order correlator (FOTOC)","text":"","category":"section"},{"location":"TruncatedWignerApproximationExamples/","page":"Truncated Wigner Approximation","title":"Truncated Wigner Approximation","text":"The FOTOC is a quantum-equivalent of the classcal Lyapunov exponent. It is just the variance textvar(Q)+textvar(q)+textvar(P)+textvar(p) as a function of time. It may be calculated using the TWA.  (See Ref. [9] and references therein).","category":"page"},{"location":"TruncatedWignerApproximationExamples/","page":"Truncated Wigner Approximation","title":"Truncated Wigner Approximation","text":"using Dicke.ClassicalDicke\nusing Dicke.ClassicalSystems\nusing Dicke.TruncatedWignerApproximation\nusing Plots\nsystem = ClassicalDickeSystem(Ï‰=1.0, Î³=1.0, Ï‰â‚€=1.0)\n\nts = 0:0.1:50\nj = 1000\nx = Point(system, Q=1, P=0, p=0, Ïµ=-0.6)\nW = coherent_Wigner_HWxSU2(x, j=j)\nN = 10000\nif !on_github N=200 end #hide\nif !on_github times=0:1:10 end #hide\n\nFOTOC=sum.(variance(system; observable=[:Q,:q,:P,:p], \n                    distribution=W, N=N, ts=ts, tol=1e-8))\n\nplot(ts, FOTOC, \n     xlabel=\"time\", ylabel=\"FOTOC\",\n     label=\"FOTOC\", yscale=:log10)\nlyapunov = lyapunov_exponent(system, uâ‚€=x)\nplot!(t->exp(2*lyapunov*t)*2/j, 0, 14, \n    label=\"exp(2Î»t)*2Ä§\", key=:bottomright)\nsavefig(\"FOTOC_TWA.svg\");nothing #hide.","category":"page"},{"location":"TruncatedWignerApproximationExamples/","page":"Truncated Wigner Approximation","title":"Truncated Wigner Approximation","text":"(Image: )","category":"page"},{"location":"TruncatedWignerApproximationExamples/#semiclassicalLDoS","page":"Truncated Wigner Approximation","title":"Energy profiles of a coherent state","text":"","category":"section"},{"location":"TruncatedWignerApproximationExamples/","page":"Truncated Wigner Approximation","title":"Truncated Wigner Approximation","text":"We have a semiclassical formula for the energy width of a coherent state, given in App. A of Ref. [5], and implemented in ClassicalDicke.energy_width_of_coherent_state. Let's check this formula against the semiclassical local density of states given by Eq. (E.3) of Ref. [14].","category":"page"},{"location":"TruncatedWignerApproximationExamples/","page":"Truncated Wigner Approximation","title":"Truncated Wigner Approximation","text":"using Dicke.ClassicalDicke\nusing Dicke.ClassicalSystems\nusing Dicke.TruncatedWignerApproximation\nusing Distributions\nusing Plots\nsystem = ClassicalDickeSystem(Ï‰=1.0, Î³=1.0, Ï‰â‚€=1.0)\n\nts = 0:0.1:50\nj = 1000\nÏµâ‚“ = -0.5\nx = Point(system, Q=-1, P=0, p=0, Ïµ=Ïµâ‚“)\nW = coherent_Wigner_HWxSU2(x, j=j)\nN = 1000000\n\nhamiltonian = ClassicalDicke.hamiltonian(system)\nÏµ_binsize = 0.01\nif !on_github N=1000 end #hide\nif !on_github Ïµ_binsize=0.1 end #hide\n\nÏµs = -0.8:Ïµ_binsize:0\nÏ = calculate_distribution(system, distribution=W, \n    N=N,x=hamiltonian,xs=Ïµs)'\nÏ /= sum(Ï)*Ïµ_binsize #normalization\nÏƒâ‚“ = energy_width_of_coherent_state(system, x, j)\ngaussian=Distributions.Normal(Ïµâ‚“, Ïƒâ‚“)\n\nplot(Ïµs,Ï, label=\"âˆ« w(x) Î´(Ïµ - h(x)) dx\")\nplot!(Ïµ->pdf(gaussian,Ïµ), Ïµs, \n    label=\"normal(Ïƒ)\", linestyle=:dash,\n    xlabel=\"Ïµ\", ylabel=\"Probability density\")\nsavefig(\"LDoS_classical.svg\");nothing #hide.","category":"page"},{"location":"TruncatedWignerApproximationExamples/","page":"Truncated Wigner Approximation","title":"Truncated Wigner Approximation","text":"(Image: )","category":"page"},{"location":"TruncatedWignerApproximationExamples/","page":"Truncated Wigner Approximation","title":"Truncated Wigner Approximation","text":"See this example for the full quantum computation of the energy spectrum of a coherent state.","category":"page"},{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"DickeBCEExamples/#Examples-for-DickeBCE","page":"Quantum Dicke (DickeBCE)","title":"Examples for DickeBCE","text":"","category":"section"},{"location":"DickeBCEExamples/","page":"Quantum Dicke (DickeBCE)","title":"Quantum Dicke (DickeBCE)","text":"push!(LOAD_PATH,\"../../src\")\non_github=get(ENV, \"CI\", nothing) == \"true\"\ncache_fold_name=\"./diags\"\nuse_current_dir_for_diags_and_remove=on_github\non_github=false\nusing Dicke","category":"page"},{"location":"DickeBCEExamples/","page":"Quantum Dicke (DickeBCE)","title":"Quantum Dicke (DickeBCE)","text":"The module Dicke.DickeBCE works with the quantum Dicke model using a very efficient basis known as the coherent efficient basis (BCE for its acronym in Spanish). See Refs. [3] and [4] for a detailed explanation on how and why it works.  Throughout this examples, we will work with a system size of j = 30, but  using this module you can easily go up to j = 100 (and probably beyond, depending on the energy regime you are interested in studying).","category":"page"},{"location":"DickeBCEExamples/#Diagonalizing-the-Dicke-Hamiltonian","page":"Quantum Dicke (DickeBCE)","title":"Diagonalizing the Dicke Hamiltonian","text":"","category":"section"},{"location":"DickeBCEExamples/","page":"Quantum Dicke (DickeBCE)","title":"Quantum Dicke (DickeBCE)","text":"Let us start by defining our parameters:","category":"page"},{"location":"DickeBCEExamples/","page":"Quantum Dicke (DickeBCE)","title":"Quantum Dicke (DickeBCE)","text":"using Dicke.DickeBCE, Dicke.ClassicalDicke\nsystemQ = QuantumDickeSystem(Ï‰=1.0, Î³=1.0, Ï‰â‚€=1.0, j=30, Nmax=120)\nnothing; #hide","category":"page"},{"location":"DickeBCEExamples/","page":"Quantum Dicke (DickeBCE)","title":"Quantum Dicke (DickeBCE)","text":"To load the eigenbasis, simply use diagonalization:","category":"page"},{"location":"DickeBCEExamples/","page":"Quantum Dicke (DickeBCE)","title":"Quantum Dicke (DickeBCE)","text":"if !use_current_dir_for_diags_and_remove #hide\n@time eigenenergies,eigenstates =  diagonalization(systemQ)\nelse #hide\n@time eigenenergies,eigenstates =  diagonalization(systemQ, cache_folder=cache_fold_name)  #hide\nend #hide\nnothing; #hide","category":"page"},{"location":"DickeBCEExamples/","page":"Quantum Dicke (DickeBCE)","title":"Quantum Dicke (DickeBCE)","text":"This saves the diagonalization to disk, so next time you can do:","category":"page"},{"location":"DickeBCEExamples/","page":"Quantum Dicke (DickeBCE)","title":"Quantum Dicke (DickeBCE)","text":"systemQ = QuantumDickeSystem(Ï‰=1.0, Î³=1.0, Ï‰â‚€=1.0, j = 30) \nif !use_current_dir_for_diags_and_remove #hide\n@time eigenenergies,eigenstates =  diagonalization(systemQ)\nelse #hide\n@time eigenenergies,eigenstates =  diagonalization(systemQ,cache_folder=cache_fold_name) #hide\nrm(cache_fold_name,recursive=true)\nend #hide\nnothing; #hide","category":"page"},{"location":"DickeBCEExamples/","page":"Quantum Dicke (DickeBCE)","title":"Quantum Dicke (DickeBCE)","text":"(Note that we did not have to pass Nmax this time, it loaded it from disk.)","category":"page"},{"location":"DickeBCEExamples/","page":"Quantum Dicke (DickeBCE)","title":"Quantum Dicke (DickeBCE)","text":"The resulting eigenstates form a matrix. To get the kth eigenstate, simply do state_k = eigenstates[:,k].","category":"page"},{"location":"DickeBCEExamples/#quantumldoscoherentstateex","page":"Quantum Dicke (DickeBCE)","title":"Local density of states of a coherent state","text":"","category":"section"},{"location":"DickeBCEExamples/","page":"Quantum Dicke (DickeBCE)","title":"Quantum Dicke (DickeBCE)","text":"In this example, we obtain the eigenenergy components of a coherent state.","category":"page"},{"location":"DickeBCEExamples/","page":"Quantum Dicke (DickeBCE)","title":"Quantum Dicke (DickeBCE)","text":"using Plots\nusing Dicke.DickeBCE, Dicke.ClassicalDicke\nj = 30\nsystemC = ClassicalDickeSystem(Ï‰=1.0, Î³=1.0, Ï‰â‚€=1.0)\nsystemQ = QuantumDickeSystem(systemC, j = j, Nmax=120)\nif false #hide\neigenenergies,eigenstates = diagonalization(systemQ) \nend #hide\n\nÏµâ‚“ = -0.5\nx = Point(systemC, Q=-1, P=0, p=0, Ïµ=Ïµâ‚“)\ncoherent_state = coherentBCE(systemQ, x)\ncoherent_state_eigenbasis = transpose(eigenstates)*coherent_state \nabscâ‚–Â²=abs2.(coherent_state_eigenbasis)\nÏµâ‚–s = eigenenergies/j\n\n   \nplot(histogram(Ïµâ‚–s, weights=abscâ‚–Â²,\n        ylabel=\"Probability density\", xticks=:none,normed=true,nbins=50),\n    \n    scatter(Ïµâ‚–s, abscâ‚–Â², ylabel=\"|câ‚–|Â²\", xlabel=\"Ïµ\"),\n    \n   size=(700,500), key=false, layout=(@layout [Â°;Â°]),\n   xlim=(Ïµâ‚–s[1],Ïµâ‚–s[end]))\nsavefig(\"LDoS_quantum.svg\");nothing #hide","category":"page"},{"location":"DickeBCEExamples/","page":"Quantum Dicke (DickeBCE)","title":"Quantum Dicke (DickeBCE)","text":"(Image: )","category":"page"},{"location":"DickeBCEExamples/","page":"Quantum Dicke (DickeBCE)","title":"Quantum Dicke (DickeBCE)","text":"See this example for a semiclassical computation of the envelope of this function.","category":"page"},{"location":"DickeBCEExamples/#Survival-probability-of-coherent-state","page":"Quantum Dicke (DickeBCE)","title":"Survival probability of coherent state","text":"","category":"section"},{"location":"DickeBCEExamples/","page":"Quantum Dicke (DickeBCE)","title":"Quantum Dicke (DickeBCE)","text":"Let us compare the survival probability of a coherent state, with the truncated Wigner approximation. (See Ref. [14])","category":"page"},{"location":"DickeBCEExamples/","page":"Quantum Dicke (DickeBCE)","title":"Quantum Dicke (DickeBCE)","text":"using Plots\nimport Dicke.TruncatedWignerApproximation\nusing Dicke.DickeBCE, Dicke.ClassicalDicke\nj = 30\nsystemC = ClassicalDickeSystem(Ï‰=1.0, Î³=1.0, Ï‰â‚€=1.0)\nsystemQ = QuantumDickeSystem(systemC, j = j, Nmax=120)\nif false #hide\neigenenergies,eigenstates =  diagonalization(systemQ) \nend #hide\n\nx = Point(systemC, Q=1.75, P=0, p=0, Ïµ=-0.5)\ncoherent_state=coherentBCE(systemQ, x)\nts=exp10.(-2:0.01:3)\n\nN=20000\nif !on_github N=1000 end\nclassical_SP = TruncatedWignerApproximation.survival_probability(\n    systemC; \n    distribution=TruncatedWignerApproximation.coherent_Wigner_HWxSU2(x,j=j),\n    N=N, ts=ts\n)\nquantum_SP = DickeBCE.survival_probability(\n    ts,\n    state=coherent_state, \n    eigenstates=eigenstates, \n    eigenenergies=eigenenergies\n)\n\nplot(ts, quantum_SP, yscale=:log10, xscale=:log10, \n    label=\"TWA\", xlabel=\"time\", ylabel=\"Survival probability\")\nplot!(ts, classical_SP, label=\"Quantum\", ylim=(1e-4,1))\nsavefig(\"SP_QvsTWA.svg\");nothing #hide","category":"page"},{"location":"DickeBCEExamples/","page":"Quantum Dicke (DickeBCE)","title":"Quantum Dicke (DickeBCE)","text":"(Image: )","category":"page"},{"location":"DickeBCEExamples/#exampletolhusimis","page":"Quantum Dicke (DickeBCE)","title":"Efficient Husimi functions","text":"","category":"section"},{"location":"DickeBCEExamples/","page":"Quantum Dicke (DickeBCE)","title":"Quantum Dicke (DickeBCE)","text":"The functions DickeBCE.Husimi,  DickeBCE.coherentOverlap, and DickeBCE.coherentBCE all accept a tol argument, which allows to significally speed up computation time at the cost of slight numerical precision [8]. In this example we show how significant this speedup can be. Let us construct a big system (Do not try to diagonalize such a big system! Your computer might explode!)","category":"page"},{"location":"DickeBCEExamples/","page":"Quantum Dicke (DickeBCE)","title":"Quantum Dicke (DickeBCE)","text":"using Dicke\nusing Dicke.DickeBCE\nusing Dicke.ClassicalDicke\nusing LinearAlgebra\n\nj = 600\nNmax = 1200\nsystem = QuantumDickeSystem(Ï‰â‚€=1, Ï‰=1, Î³=1, j=j, Nmax=Nmax);\nnothing; #hide","category":"page"},{"location":"DickeBCEExamples/","page":"Quantum Dicke (DickeBCE)","title":"Quantum Dicke (DickeBCE)","text":"For the sake of example, let us construct some random in a simple manner (although if you are interested in building random states in the eigenbasis, check the function DickeBCE.randomState).","category":"page"},{"location":"DickeBCEExamples/","page":"Quantum Dicke (DickeBCE)","title":"Quantum Dicke (DickeBCE)","text":"n = 3 #how many random vectors\nD = dimension(system)\nrandom_vectors = rand(ComplexF64,(D,n))\nfor i in 1:n\n    random_vectors[:,i] /= norm(@view random_vectors[:,i]) #normalize each one\nend \nnothing; #hide","category":"page"},{"location":"DickeBCEExamples/","page":"Quantum Dicke (DickeBCE)","title":"Quantum Dicke (DickeBCE)","text":"random_vectors is a matrix with n columns (states). Let us fix a point in the phase space:","category":"page"},{"location":"DickeBCEExamples/","page":"Quantum Dicke (DickeBCE)","title":"Quantum Dicke (DickeBCE)","text":"x = Point(Q=0.6, P=-0.1, p=-0.2, q=-0.8)\nnothing; #hide","category":"page"},{"location":"DickeBCEExamples/","page":"Quantum Dicke (DickeBCE)","title":"Quantum Dicke (DickeBCE)","text":"We may call Husimi(system, x, random_vectors), which will return an array with n elements. The ith element is the result of evaluating the Husimi function  of the ith state (column) at the point x.","category":"page"},{"location":"DickeBCEExamples/","page":"Quantum Dicke (DickeBCE)","title":"Quantum Dicke (DickeBCE)","text":"Husimi(system,x,random_vectors)","category":"page"},{"location":"DickeBCEExamples/","page":"Quantum Dicke (DickeBCE)","title":"Quantum Dicke (DickeBCE)","text":"@time Husimi(system, x, random_vectors, tol=0)","category":"page"},{"location":"DickeBCEExamples/","page":"Quantum Dicke (DickeBCE)","title":"Quantum Dicke (DickeBCE)","text":"By passing tol=0 we are allowing for no optimization. The code has to build all the coefficients of the coherent state and then multiply them by each coefficient in random_vectors. However, if we allow tol to be slightly bigger, things will speed up significantly:","category":"page"},{"location":"DickeBCEExamples/","page":"Quantum Dicke (DickeBCE)","title":"Quantum Dicke (DickeBCE)","text":"@time Husimi(system, x, random_vectors, tol=1e-15)","category":"page"},{"location":"DickeBCEExamples/","page":"Quantum Dicke (DickeBCE)","title":"Quantum Dicke (DickeBCE)","text":"Note that the results barely changed, but this time it used a lot less memory and time. The tol argument tells the code it can chop a portion of size tol off the tails of the distribution of the coherent state (see Ref. [8] for details). You loose almost no information,  and you gain a lot of time. The default is tol = 1e-6, which gives enough precision for most purposes (although you may increase it if you need more precision):","category":"page"},{"location":"DickeBCEExamples/","page":"Quantum Dicke (DickeBCE)","title":"Quantum Dicke (DickeBCE)","text":"@time Husimi(system, x, random_vectors) #default tol = 1e-6","category":"page"},{"location":"DickeBCEExamples/","page":"Quantum Dicke (DickeBCE)","title":"Quantum Dicke (DickeBCE)","text":"That's fast!","category":"page"},{"location":"DickeBCEExamples/#wignerfuncexample","page":"Quantum Dicke (DickeBCE)","title":"Projected Wigner function of a cat state","text":"","category":"section"},{"location":"DickeBCEExamples/","page":"Quantum Dicke (DickeBCE)","title":"Quantum Dicke (DickeBCE)","text":"Using DickeBCE.WignerProjqp, we may compute the Wigner function of a state, projected onto the atomic plane. Note: the functions for computing Wigner functions are not thoroughly tested. They are based on these notes [7]","category":"page"},{"location":"DickeBCEExamples/","page":"Quantum Dicke (DickeBCE)","title":"Quantum Dicke (DickeBCE)","text":"using Dicke.ClassicalDicke, Dicke.DickeBCE\nsystemC = ClassicalDickeSystem(Ï‰=1.0, Î³=1.0, Ï‰â‚€=1.0)\nsystemQ = QuantumDickeSystem(systemC, j=10, Nmax=50) \nres=0.05\nif !on_github res=0.2 end #end\nQs=Ps=-2:res:2\npts=[[Q,P] for Q in Qs, P in Ps if Q^2+P^2 <= 4]\n\nx = Point(Q=-1.0, P=0, p=0, q=0)\ny = Point(Q= 1.0, P=0, p=0, q=0)\nðŸ± = 1/sqrt(2) * (coherentBCE(systemQ, x) + coherentBCE(systemQ, y))\n\nW=DickeBCE.WignerProjqp(systemQ, \n                    [ðŸ±], \n                    pts\n                    ,show_progress = false, #hide\n                    )[1]\nd=Dict(zip(pts,W))\nfunction mW(Q,P)\n    if [Q,P] in pts\n        return d[[Q,P]]\n    else\n        return NaN\n    end\nend\nheatmap(Qs, Ps, mW, size=(600,600),\n    xlabel = \"Q\", ylabel = \"P\",\n    c=cgrad(:bwr, rev = true), clim=(-2.5,2.5))\nsavefig(\"catWigner.svg\");nothing #hide","category":"page"},{"location":"DickeBCEExamples/","page":"Quantum Dicke (DickeBCE)","title":"Quantum Dicke (DickeBCE)","text":"(Image: )","category":"page"},{"location":"DickeHusimiProjections/#Dicke.DickeHusimiProjections","page":"DickeHusimiProjections","title":"Dicke.DickeHusimiProjections","text":"","category":"section"},{"location":"DickeHusimiProjections/","page":"DickeHusimiProjections","title":"DickeHusimiProjections","text":"Modules = [Dicke.DickeHusimiProjections]\nOrder   = [:type,:function]","category":"page"},{"location":"DickeHusimiProjections/#Dicke.DickeHusimiProjections.matrix_QPâˆ«âˆ«dqdpÎ´Ïµ-Tuple{Dicke.ClassicalDicke.ClassicalDickeSystem}","page":"DickeHusimiProjections","title":"Dicke.DickeHusimiProjections.matrix_QPâˆ«âˆ«dqdpÎ´Ïµ","text":"function matrix_QPâˆ«âˆ«dqdpÎ´Ïµ(system::ClassicalDickeSystem;\n    f::Function,\n    Ïµ::Real,\n    res::Real=0.1,\n    symmetricQP::Bool=false,\n    symmetricP::Bool=symmetricQP,\n    paralelize::Bool=(Distributed.myid()==1),\n    showprogress::Bool = true,\n    pbatch_size::Integer=Int(min(ceil((4/res)^2/Distributed.nprocs()/10),50)))\n\nReturns  a tuple (Qs, Ps, mat) where Qs and Ps are real vectors spanning all possible values of P and Q with some step res, and mat  is a matrix whose entries are given by mat[i,j] =âˆ«âˆ«dqdpÎ´Ïµ(system; Ïµ=Ïµ, Q=Qs[i], P=P[j], p_res=res,kargs...)\n\nArguments\n\nsystem should be an instance of ClassicalDicke.ClassicalDickeSystem.\nÏµ is a real number (see arguments for âˆ«âˆ«dqdpÎ´Ïµ).\nf should be function with signature f([Q,q,P,p]) that returns values that may be added together (Numbers, Arrays etc...).\nres determines the separation between the elements of Qs and Ps. It also determines p_res in the calls to âˆ«âˆ«dqdpÎ´Ïµ.\nsymmetricQP indicates that f([Q,q,P,p]) = f([-Q,q,P,p]) = f([Q,q,-P,p]) for all Q and P. If true only the non-positive entries of Q and P will be computed, and the other entries will be mirrored.  Default is false.\nsymmetricP indicates that f([Q,q,-P,p]) = f([Q,q,P,p]) for all P. If true, only the side with  non-positive P coordinate will be comptued, and the other entries will be mirrored. The default is to  be the same that symmetricQP.\nparalelize indicates whether to use all available workers. Defaults to true if this function is called  from worker 1, and false else.\nshowprogress turns the progress bar on/off. Default is true.\npbatch_size is the maximum number of batches to run in a single run in a single worker. The default value is automatically optimized depending on res and the number of workers.\nkargs... are redirected to âˆ«âˆ«dqdpÎ´Ïµ.\n\n\n\n\n\n","category":"method"},{"location":"DickeHusimiProjections/#Dicke.DickeHusimiProjections.âˆ«âˆ«dqdpÎ´Ïµ","page":"DickeHusimiProjections","title":"Dicke.DickeHusimiProjections.âˆ«âˆ«dqdpÎ´Ïµ","text":"function âˆ«âˆ«dqdpÎ´Ïµ(system::ClassicalDickeSystem;\n    Ïµ::Real,\n    Q::Real,\n    P::Real,\n    f::Function,\n    p_res::Real=0.01,\n    nonvalue=nothing,\n    onlyqroot::Union{typeof(-),typeof(+),Nothing}=nothing)\n\nComputes the integral  \n\n    int int dq dp f(mathbfx) delta(h_textcl(mathbfx) - epsilon)\n\nusing Eq. (8) of Ref. [11] and a  Chebyshevâ€“Gauss quadrature method.  \n\nNote: to type âˆ« in Julia, type \\int + Tab.\n\nArguments\n\nsystem should be an instance of ClassicalDicke.ClassicalDickeSystem.\nÏµ is a real number corresponding to epsilon above.\nQ and P are the Q and P coordinates of mathbfx above.\nf should be function with signature f([Q,q,P,p]) that returns values that may be added together (Numbers, Arrays etc...).\np_res is the resolution of the integral. The amount of nodes for the quadrature will be equal to 2*floor(pâ‚Š/p_res) + 1, where pâ‚Š is defined below Eq. (9) of Ref. [11]. Default is 0.01.\nnonvalue is the value to return if QP are outside of the energy shell at epsilon. Default is NaN.\nonlyqroot may be +, -, or nothing (default). If it is + (-), the integral is only computed over the positive (negative) roots in q, that is, only the q_+ (q_-) term is taken in Eq. (8) of Ref. [11]. If it is nothing, both terms are added.\n\n\n\n\n\n","category":"function"},{"location":"DickeHusimiProjections/#Dicke.DickeHusimiProjections.âˆ«âˆ«dqdpÎ´Ïµ_Husimi_Renyi_powers-Tuple{Dicke.DickeBCE.QuantumDickeSystem}","page":"DickeHusimiProjections","title":"Dicke.DickeHusimiProjections.âˆ«âˆ«dqdpÎ´Ïµ_Husimi_Renyi_powers","text":"function âˆ«âˆ«dqdpÎ´Ïµ_Husimi_Renyi_powers(\n    systemQ::DickeBCE.QuantumDickeSystem;\n    states::Union{Array{<:Number,1},Array{<:Number,2}},\n    res::Real,\n    Htol::Real=1e-4,\n    nonvalue=NaN,\n    averageallstates::Bool=false,\n    averagingfunction::Function=mean,\n    Î±::Union{AbstractArray{<:Real,1},Real}=2,\n    kargs...)\n\nCalls matrix_QPâˆ«âˆ«dqdpÎ´Ïµ PENDING\n\n\n\n\n\n","category":"method"},{"location":"TruncatedWignerApproximation/#Dicke.TruncatedWignerApproximation","page":"TruncatedWignerApproximation","title":"Dicke.TruncatedWignerApproximation","text":"","category":"section"},{"location":"TruncatedWignerApproximation/","page":"TruncatedWignerApproximation","title":"TruncatedWignerApproximation","text":"Modules = [Dicke.TruncatedWignerApproximation]\nOrder   = [:type,:function]","category":"page"},{"location":"TruncatedWignerApproximation/#Dicke.TruncatedWignerApproximation.MonteCarloSystem","page":"TruncatedWignerApproximation","title":"Dicke.TruncatedWignerApproximation.MonteCarloSystem","text":"struct MonteCarloSystem\n\nThis object may be passed to monte_carlo_integrate. Use mcs_for_averaging,  mcs_for_variance, and mcs_for_survival_probability to generate them,  and mcs_chain to join them together.\n\n\n\n\n\n","category":"type"},{"location":"TruncatedWignerApproximation/#Dicke.TruncatedWignerApproximation.PhaseSpaceDistribution","page":"TruncatedWignerApproximation","title":"Dicke.TruncatedWignerApproximation.PhaseSpaceDistribution","text":"struct PhaseSpaceDistribution\n\nThis object represents a probability distribution in the phase space. Currently, the only  implementation is through coherent_Wigner_HWxSU2.\n\n\n\n\n\n","category":"type"},{"location":"TruncatedWignerApproximation/#Dicke.TruncatedWignerApproximation.average-Tuple{Dicke.ClassicalSystems.ClassicalSystem}","page":"TruncatedWignerApproximation","title":"Dicke.TruncatedWignerApproximation.average","text":"function average(system::ClassicalSystems.ClassicalSystem, \n    [[[same kargs as mcs_for_averaging]]],\n    kargs...)\n\nCalls mcs_for_averaging and then monte_carlo_integrate on the resulting MonteCarloSystem. Extra kargs are sent to the latter.\n\n\n\n\n\n","category":"method"},{"location":"TruncatedWignerApproximation/#Dicke.TruncatedWignerApproximation.calculate_distribution-Tuple{Dicke.ClassicalSystems.ClassicalSystem}","page":"TruncatedWignerApproximation","title":"Dicke.TruncatedWignerApproximation.calculate_distribution","text":"function calculate_distribution(system::ClassicalSystems.ClassicalSystem, \n    [[[same kargs as mcs_for_distributions]]],\n    kargs...)\n\nCalls mcs_for_distributions and then monte_carlo_integrate on the resulting MonteCarloSystem. Extra kargs are sent to the latter.\n\n\n\n\n\n","category":"method"},{"location":"TruncatedWignerApproximation/#Dicke.TruncatedWignerApproximation.coherent_Wigner_HW-Tuple{Any}","page":"TruncatedWignerApproximation","title":"Dicke.TruncatedWignerApproximation.coherent_Wigner_HW","text":"function  coherent_Wigner_HW(uâ‚€::AbstractVector{<:Real},j::Real=1,Ä§::Real=1/j)\n\nSame as coherent_Wigner_HW, taking uâ‚€ = [qâ‚€, pâ‚€].\n\n\n\n\n\n","category":"method"},{"location":"TruncatedWignerApproximation/#Dicke.TruncatedWignerApproximation.coherent_Wigner_HW-Tuple{}","page":"TruncatedWignerApproximation","title":"Dicke.TruncatedWignerApproximation.coherent_Wigner_HW","text":"function coherent_Wigner_HW(;qâ‚€::Real,pâ‚€::Real,j::Real=1,Ä§::Real=1/j)\n\nReturns a PhaseSpaceDistribution corresponding to the two-dimensional Wigner function of a coherent state of the Heisenberg-Weyl algebra (i.e. a standard coherent state)  centered at qâ‚€,pâ‚€. A value of Ä§ may be passed, or pass j to set Ä§ = 1/j. (See Eq. (B.1) of Ref. [14])\n\n\n\n\n\n","category":"method"},{"location":"TruncatedWignerApproximation/#Dicke.TruncatedWignerApproximation.coherent_Wigner_HWxSU2-Tuple{AbstractVector{var\"#s142\"} where var\"#s142\"<:Real}","page":"TruncatedWignerApproximation","title":"Dicke.TruncatedWignerApproximation.coherent_Wigner_HWxSU2","text":"function  coherent_Wigner_HWxSU2(uâ‚€::AbstractVector{<:Real},j::Real=1,Ä§::Real=1/j)\n\nSame as coherent_Wigner_HWxSU2, taking uâ‚€ = [Qâ‚€, qâ‚€, Pâ‚€, pâ‚€].\n\n\n\n\n\n","category":"method"},{"location":"TruncatedWignerApproximation/#Dicke.TruncatedWignerApproximation.coherent_Wigner_HWxSU2-Tuple{}","page":"TruncatedWignerApproximation","title":"Dicke.TruncatedWignerApproximation.coherent_Wigner_HWxSU2","text":"function coherent_Wigner_HWxSU2(;Qâ‚€::Real,qâ‚€::Real,Pâ‚€::Real,pâ‚€::Real,j::Real=1,Ä§::Real=1/j)\n\nProduces the Wigner function corresponding to the tensor product of coherent_Wigner_HW and coherent_Wigner_SU2.\n\n\n\n\n\n","category":"method"},{"location":"TruncatedWignerApproximation/#Dicke.TruncatedWignerApproximation.coherent_Wigner_SU2-Tuple{Any}","page":"TruncatedWignerApproximation","title":"Dicke.TruncatedWignerApproximation.coherent_Wigner_SU2","text":"function  coherent_Wigner_SU2(uâ‚€::AbstractVector{<:Real},j::Real=1,Ä§::Real=1/j)\n\nSame as coherent_Wigner_SU2, taking uâ‚€ = [Qâ‚€, Pâ‚€].\n\n\n\n\n\n","category":"method"},{"location":"TruncatedWignerApproximation/#Dicke.TruncatedWignerApproximation.coherent_Wigner_SU2-Tuple{}","page":"TruncatedWignerApproximation","title":"Dicke.TruncatedWignerApproximation.coherent_Wigner_SU2","text":"function coherent_Wigner_HW(;Qâ‚€::Real,Pâ‚€::Real,j::Real=1,Ä§::Real=1/j)\n\nSame as coherent_Wigner_HW, but for a coherent state for the SU(2)  algebra (a Bloch coherent state).  The approximation given by Eq. (B.4) of Ref. [14] is used.\n\n\n\n\n\n","category":"method"},{"location":"TruncatedWignerApproximation/#Dicke.TruncatedWignerApproximation.mcs_chain-Tuple{AbstractVector{Dicke.TruncatedWignerApproximation.MonteCarloSystem}}","page":"TruncatedWignerApproximation","title":"Dicke.TruncatedWignerApproximation.mcs_chain","text":"function mcs_chain(Fs::AbstractArray{MonteCarloSystem,1})\n\nGenerates a MonteCarloSystem by chaining together those in the array Fs = [monteCarloSystem1, monteCarloSystem2, ...]. The output of the system generated is an array that has the outputs of each system, in the same order as Fs.\n\n\n\n\n\n","category":"method"},{"location":"TruncatedWignerApproximation/#Dicke.TruncatedWignerApproximation.mcs_chain-Union{Tuple{Vararg{Dicke.TruncatedWignerApproximation.MonteCarloSystem, N}}, Tuple{N}} where N","page":"TruncatedWignerApproximation","title":"Dicke.TruncatedWignerApproximation.mcs_chain","text":"function mcs_chain(mcs1::MonteCarloSystem, mcs2::MonteCarloSystem, ...)\n\nFunctionally equivalent to mcs_chain([mcs1, mcs2, ...]).\n\n\n\n\n\n","category":"method"},{"location":"TruncatedWignerApproximation/#Dicke.TruncatedWignerApproximation.mcs_for_averaging-Tuple{Dicke.ClassicalSystems.ClassicalSystem}","page":"TruncatedWignerApproximation","title":"Dicke.TruncatedWignerApproximation.mcs_for_averaging","text":"function mcs_for_averaging(\n    system::ClassicalSystems.ClassicalSystem;\n    observable,\n    ts::AbstractVector{<:Real}=[0.0],\n    N::Integer,\n    distribution::PhaseSpaceDistribution)\n\nGenerates a MonteCarloSystem that computes\n\n    frac1N sum_i=1^N textobservable(mathbfx_i(t))\n\nfor each t in ts, where mathbfx_i will be sampled from distribution. The system produces an array the same size as ts, containing the result for each time.\n\nArguments\n\nsystem should be an instance of ClassicalSystems.ClassicalSystem,\nobservable can a function in the form f(x::Vector) or f(x1,x2 ,..., x_n) with  n the dimension of the phase space determined by system. observable can also be an expression determining the operations between the varnames determined by system. For example, if system were a instance of ClassicalDicke.ClassicalDickeSystem, then observable could be :(q+p^2 +Q), f(Q, q, P, p) = q + p^2 - Q or f(x) = x[2] + x[4]^2 - x[1], which are all equivalent. See also the submodule Weyl, which produces expressions corresponding to  the Weyl symbols of quantum observables.   Note: observable can also be an array of observables, in which case an array is returned for each time.\nts should be a sorted array of times.\nN is the number of points to sample. The bigger the more accurate.\ndistribution should be an instance of PhaseSpaceDistribution\n\n\n\n\n\n","category":"method"},{"location":"TruncatedWignerApproximation/#Dicke.TruncatedWignerApproximation.mcs_for_distributions-Tuple{Dicke.ClassicalSystems.ClassicalSystem}","page":"TruncatedWignerApproximation","title":"Dicke.TruncatedWignerApproximation.mcs_for_distributions","text":"function mcs_for_distributions(system::ClassicalSystems.ClassicalSystem;\n    x,\n    xs::Union{AbstractRange{<:Real},Nothing}=nothing,\n    y=nothing,\n    ts::Union{AbstractRange{<:Real},Nothing}=nothing,\n    animate::Bool=false,\n    ys::Union{AbstractRange{<:Real},Nothing}=nothing,\n    N::Integer,\n    distribution::PhaseSpaceDistribution)\n\nGenerates a MonteCarloSystem that produces a multidimensional histogram allowing to visualize the expected value of observables under PhaseSpaceDistribution distribution.\n\nSeveral behaviors can be produced.\n\nIf x is :t, a matrix of dimensions length(ts) times length(ys)  is produced. The coordinate (táµ¢,yâ±¼) gives the probability of finding the observable y between ys[j] and ys[j+1] at the time ts[i].\nIf y is :t, the same as above, changing x by y.\nIf neither x nor y are :t, and animate = false, then a matrix of dimensions length(xs) times length(ys)  is produced.  The coordinate (xáµ¢,yâ±¼) gives the probability of finding the observable x between xs[i] and xs[i+1] and the observable y between ys[j] and ys[j+1], averaging over all the times in ts\nIf neither x nor y are t, and animate = true then an array of matrices of dimensions length(xs) times length(ys)  is produced, the same size as ts. For the nth matrix in this array, the coordinate (xáµ¢,yâ±¼) gives the probability of finding the observable x between xs[i] and xs[i+1] and the observable y between ys[j] and ys[j+1] at time ts[n].\n\nArguments\n\nsystem should be an instance of ClassicalSystems.ClassicalSystem,\nx and y can be :t, or an observable as described in the arguments of mcs_for_averaging.\nxs and ys should be given if  x and  y are not  :t, in wich case they should be range objects (e.g. 0:0.1:1) containing the bins for the histogram.\nts should be a range object (e.g. 0:0.1:1) of times.\nanimate should be a Bool, which determines the behavior if neither x nor y are t. Defaults to true\nN is the number of points to sample. The bigger the more accurate.\ndistribution should be an instance of PhaseSpaceDistribution\n\nNote: If ts and y are both not passed, then y is set to :t and ts to 0:0.\n\n\n\n\n\n","category":"method"},{"location":"TruncatedWignerApproximation/#Dicke.TruncatedWignerApproximation.mcs_for_survival_probability-Tuple{Dicke.ClassicalSystems.ClassicalSystem}","page":"TruncatedWignerApproximation","title":"Dicke.TruncatedWignerApproximation.mcs_for_survival_probability","text":"function mcs_for_survival_probability(\n    system::ClassicalSystems.ClassicalSystem;\n    N::Integer,\n    ts::AbstractArray{<:Real},\n    distribution::PhaseSpaceDistribution)\n\nGenerates a MonteCarloSystem that computes the survival probability through Eq. (C.7) of Ref. [14] (with M= N, w= distribution).\n\nArguments\n\nsystem should be an instance of ClassicalSystems.ClassicalSystem,\nts should be a sorted array of times.\nN is the number of points to sample. The bigger the more accurate.\ndistribution should be an instance of PhaseSpaceDistribution\n\n\n\n\n\n","category":"method"},{"location":"TruncatedWignerApproximation/#Dicke.TruncatedWignerApproximation.mcs_for_variance-Tuple{Dicke.ClassicalSystems.ClassicalSystem}","page":"TruncatedWignerApproximation","title":"Dicke.TruncatedWignerApproximation.mcs_for_variance","text":"function mcs_for_variance(\n    system::ClassicalSystems.ClassicalSystem;\n    observable,\n    ts::AbstractVector{<:Real}=[0.0],\n    N::Integer,\n    distribution::PhaseSpaceDistribution,\n    return_average::Bool = false)\n\nGenerates a MonteCarloSystem that computes the variance\n\n    frac1N sum_i=1^N textobservable^2(mathbfx_i(t)) - left (frac1Nsum_i=1^N textobservable(mathbfx_i(t))right )^2\n\nfor each t in ts, where mathbfx_i will be sampled from distribution. The system produces an array the same size as ts, containing the result for each time.\n\nArguments\n\nSee arguments for mcs_for_averaging.\nIf return_average=false (default), only produces the variance, else it  will produce a tuple, where the first element is the variance and the second the average.\n\n\n\n\n\n","category":"method"},{"location":"TruncatedWignerApproximation/#Dicke.TruncatedWignerApproximation.monte_carlo_integrate-Tuple{Dicke.ClassicalSystems.ClassicalSystem, Dicke.TruncatedWignerApproximation.MonteCarloSystem}","page":"TruncatedWignerApproximation","title":"Dicke.TruncatedWignerApproximation.monte_carlo_integrate","text":"function monte_carlo_integrate(system::ClassicalSystems.ClassicalSystem,\n    mc_system::MonteCarloSystem;\n    tolerate_errors=true,\n    maxNBatch=Inf,kargs...)\n\nThis function is the backbone of this module. It performs a Monte Carlo integration-type procedure. The argument mc_system determines a distribution::PhaseSpaceDistribution, an integer N, and a list of times ts. This function calls an initializing function also determined by mc_system. Then, it samples N random points x from distribution, which are integrated using the Hamiltonian given by system. For each trajectory and time in ts, an operation is performed, which is determined again by mc_system. A final operation is then performed and the result is returned. This may seem a bit abstract, but it is a very flexible system. The applications are more concrete; for example, if you generate mc_system using mcs_for_averaging(... observable=f ...),  then the initial operation is to generate an array of zeroes the same length as ts. Then, for each initial condition x, the result of f(x(t)) is added to each element of the array. Finally, the array is overall divided by N and then returned. This is exactly a Monte Carlo integration of the function f(x) over the classical evolution  of the distribution.\n\nThis function uses all the available workers, but make sure to import this module in all of them.\n\nArguments:\n\nsystem should be an instance of ClassicalSystems.ClassicalSystem.\nmc_system should be an instance of  MonteCarloSystem.\ntolerate_errors indicates that some errors in the integration may be ignored. This is useful because sometimes a one-in-a-million numerical instability may arise, and you may want to ignore it. If more than 100 errors occur consecutively, then then the procedure is stopped. Defaults to true.\nmaxNBatch is the maximum number of batch-sizes sent to each worker. Defaults to inf.\nkargs are redirected to [ClassicalSystems.integrate].\n\n\n\n\n\n","category":"method"},{"location":"TruncatedWignerApproximation/#Dicke.TruncatedWignerApproximation.survival_probability-Tuple{Dicke.ClassicalSystems.ClassicalSystem}","page":"TruncatedWignerApproximation","title":"Dicke.TruncatedWignerApproximation.survival_probability","text":"function survival_probability(system::ClassicalSystems.ClassicalSystem, \n    [[[same kargs as mcs_for_survival_probability]]],\n    kargs...)\n\nCalls mcs_for_survival_probability and then monte_carlo_integrate on the resulting MonteCarloSystem. Extra kargs are sent to the latter.\n\n\n\n\n\n","category":"method"},{"location":"TruncatedWignerApproximation/#Dicke.TruncatedWignerApproximation.variance-Tuple{Dicke.ClassicalSystems.ClassicalSystem}","page":"TruncatedWignerApproximation","title":"Dicke.TruncatedWignerApproximation.variance","text":"function variance(system::ClassicalSystems.ClassicalSystem, \n    [[[same kargs as mcs_for_variance]]],\n    kargs...)\n\nCalls mcs_for_variance and then monte_carlo_integrate on the resulting MonteCarloSystem. Extra kargs are sent to the latter.\n\n\n\n\n\n","category":"method"},{"location":"TruncatedWignerApproximation/#Dicke.TruncatedWignerApproximation.Weyl","page":"TruncatedWignerApproximation","title":"Weyl symbols","text":"","category":"section"},{"location":"TruncatedWignerApproximation/","page":"TruncatedWignerApproximation","title":"TruncatedWignerApproximation","text":"The submodule TruncatedWignerApproximation.Weyl generates classical phase-space observables that may be passed as the argument observable of average, calculate_distribution, etc. All the following functions return SymEngine objects, so they may be operated as if they were numbers. ","category":"page"},{"location":"TruncatedWignerApproximation/","page":"TruncatedWignerApproximation","title":"TruncatedWignerApproximation","text":"Modules = [Dicke.TruncatedWignerApproximation.Weyl]\nOrder   = [:type,:function]","category":"page"},{"location":"TruncatedWignerApproximation/#Dicke.TruncatedWignerApproximation.Weyl.Jx-Tuple{Real}","page":"TruncatedWignerApproximation","title":"Dicke.TruncatedWignerApproximation.Weyl.Jx","text":"function Jx(j::Real)\n\nReturns the Weyl symbol of the operator hatJ_x. (See p. 114 of Ref. [13])\n\n\n\n\n\n","category":"method"},{"location":"TruncatedWignerApproximation/#Dicke.TruncatedWignerApproximation.Weyl.JxÂ²-Tuple{Real}","page":"TruncatedWignerApproximation","title":"Dicke.TruncatedWignerApproximation.Weyl.JxÂ²","text":"function JxÂ²(j::Real)\n\nReturns the Weyl symbol of the operator hatJ_x^2. (See bottom of p. 128 of Ref. [13])\n\n\n\n\n\n","category":"method"},{"location":"TruncatedWignerApproximation/#Dicke.TruncatedWignerApproximation.Weyl.Jy-Tuple{Real}","page":"TruncatedWignerApproximation","title":"Dicke.TruncatedWignerApproximation.Weyl.Jy","text":"function Jy(j::Real)\n\nReturns the Weyl symbol of the operator hatJ_y. (See p. 114 of Ref. [13])\n\n\n\n\n\n","category":"method"},{"location":"TruncatedWignerApproximation/#Dicke.TruncatedWignerApproximation.Weyl.JyÂ²-Tuple{Real}","page":"TruncatedWignerApproximation","title":"Dicke.TruncatedWignerApproximation.Weyl.JyÂ²","text":"function JyÂ²(j::Real)\n\nReturns the Weyl symbol of the operator hatJ_y^2. (See bottom of p. 128 of Ref. [13])\n\n\n\n\n\n","category":"method"},{"location":"TruncatedWignerApproximation/#Dicke.TruncatedWignerApproximation.Weyl.Jz-Tuple{Real}","page":"TruncatedWignerApproximation","title":"Dicke.TruncatedWignerApproximation.Weyl.Jz","text":"function Jz(j::Real)\n\nReturns the Weyl symbol of the operator hatJ_z. (See p. 114 of Ref. [13])\n\n\n\n\n\n","category":"method"},{"location":"TruncatedWignerApproximation/#Dicke.TruncatedWignerApproximation.Weyl.JzÂ²-Tuple{Real}","page":"TruncatedWignerApproximation","title":"Dicke.TruncatedWignerApproximation.Weyl.JzÂ²","text":"function JzÂ²(j::Real)\n\nReturns the Weyl symbol of the operator hatJ_z^2. (See bottom of p. 128 of Ref. [13])\n\n\n\n\n\n","category":"method"},{"location":"TruncatedWignerApproximation/#Dicke.TruncatedWignerApproximation.Weyl.n-Tuple{Real}","page":"TruncatedWignerApproximation","title":"Dicke.TruncatedWignerApproximation.Weyl.n","text":"function n(j::Real)\n\nReturns the Weyl symbol of the number operator W(n), (pÂ²+  qÂ² - Ä§)/2, where Ä§ = 1/j.  \n\n\n\n\n\n","category":"method"},{"location":"TruncatedWignerApproximation/#Dicke.TruncatedWignerApproximation.Weyl.nÂ²-Tuple{Real}","page":"TruncatedWignerApproximation","title":"Dicke.TruncatedWignerApproximation.Weyl.nÂ²","text":"function nÂ²(j::Real)\n\nReturns the Weyl symbol of the number operator squared W(n^2) = W(n)^2 - hbar^24, where hbar = 1j. (Note that the extra term hbar^24  appears due to the non-commutativity of q and p. See Ref. [12] for details on how to compute these expressions.\n\n\n\n\n\n","category":"method"},{"location":"ClassicalLMG/#Dicke.ClassicalLMG","page":"ClassicalLMG","title":"Dicke.ClassicalLMG","text":"","category":"section"},{"location":"ClassicalLMG/","page":"ClassicalLMG","title":"ClassicalLMG","text":"Modules = [Dicke.ClassicalLMG]\nOrder   = [:type,:function]","category":"page"},{"location":"UPOS/#Dicke.UPOS","page":"UPOS","title":"Dicke.UPOS","text":"","category":"section"},{"location":"UPOS/","page":"UPOS","title":"UPOS","text":"Modules = [Dicke.UPOS]\nOrder   = [:type,:function]","category":"page"},{"location":"ClassicalDickeExamples/#Examples-for-ClassicalDicke","page":"Classical Dicke","title":"Examples for ClassicalDicke","text":"","category":"section"},{"location":"ClassicalDickeExamples/","page":"Classical Dicke","title":"Classical Dicke","text":"push!(LOAD_PATH,\"../../src\")\non_github=get(ENV, \"CI\", nothing) == \"true\"\non_github=false\nusing Dicke","category":"page"},{"location":"ClassicalDickeExamples/#Drawing-contours-of-the-available-phase-space","page":"Classical Dicke","title":"Drawing contours of the available phase space","text":"","category":"section"},{"location":"ClassicalDickeExamples/","page":"Classical Dicke","title":"Classical Dicke","text":"We may use the function ClassicalDicke.minimum_Ïµ_for to draw the contour of the available phase space on the variables (QP).","category":"page"},{"location":"ClassicalDickeExamples/","page":"Classical Dicke","title":"Classical Dicke","text":"using Dicke.ClassicalDicke\nusing Plots\nsystem =  ClassicalDickeSystem(Ï‰=1, Î³=1, Ï‰â‚€=1)\nQs = Ps = -2:0.01:2\nÏµgs = minimum_energy(system)\ncontour(Qs, Ps,\n        (Q,P) -> minimum_Ïµ_for(system, p=0, P=P, Q=Q),\n        levels=10, clim=(Ïµgs,1), xlabel=\"Q\", ylabel=\"P\")\nsavefig(\"contourQP.svg\"); nothing #hide","category":"page"},{"location":"ClassicalDickeExamples/","page":"Classical Dicke","title":"Classical Dicke","text":"(Image: )","category":"page"},{"location":"ClassicalDickeExamples/#Plotting-the-density-of-states","page":"Classical Dicke","title":"Plotting the density of states","text":"","category":"section"},{"location":"ClassicalDickeExamples/","page":"Classical Dicke","title":"Classical Dicke","text":"Here is a plot of the semiclassical density of states","category":"page"},{"location":"ClassicalDickeExamples/","page":"Classical Dicke","title":"Classical Dicke","text":"using Dicke.ClassicalDicke\nusing Plots\nsystem = ClassicalDickeSystem(Ï‰=1, Î³=1, Ï‰â‚€=1)\nÎ½(Ïµ) = density_of_states(system, j=100, Ïµ=Ïµ)\nÏµgs = minimum_energy(system)\nplot(Î½, Ïµgs, 2, xlabel=\"Ïµ\", ylabel=\"Density of States\")\nplot!(key=false) #hide\nsavefig(\"density_of_states.svg\"); nothing #hide","category":"page"},{"location":"ClassicalDickeExamples/","page":"Classical Dicke","title":"Classical Dicke","text":"(Image: )","category":"page"},{"location":"ClassicalDickeExamples/","page":"Classical Dicke","title":"Classical Dicke","text":"This is precisely the red line in Fig. A1. of Ref. [14].","category":"page"},{"location":"ClassicalDickeExamples/#Drawing-a-PoincarÃ©-surface","page":"Classical Dicke","title":"Drawing a PoincarÃ© surface","text":"","category":"section"},{"location":"ClassicalDickeExamples/","page":"Classical Dicke","title":"Classical Dicke","text":"Here is a way to draw a PoincarÃ© surface for the Dicke model. We use ClassicalSystems.integrate to integrate a bunch of initial conditions. Using the callback system of DifferentialEquations, we save the points where p=0.","category":"page"},{"location":"ClassicalDickeExamples/","page":"Classical Dicke","title":"Classical Dicke","text":"using Dicke, Dicke.ClassicalDicke, Dicke.ClassicalSystems\nusing Plots\nusing DiffEqBase\n\nsystem=ClassicalDickeSystem(Ï‰=0.8,Î³=0.8,Ï‰â‚€=1)\nmplot=scatter(fmt=:png, key=false, markersize=1, legend=false,\n    size=(500,500), color_palette=:darkrainbow, xlabel=\"Q\", ylabel=\"P\") \n\npts = Tuple{Float64, Float64}[] #a list of points (Q,P)\nfunction save(state) #this function saves (Q,P) to pts if q = qâ‚Š (and not qâ‚‹).\n    if q_sign(system,state.u,Ïµ) == + \n        Q,q,P,p = state.u \n        push!(pts, (Q,P))  \n    end                     \nend\ncallback=ContinuousCallback((x, t, _) -> x[4], #when p=x[4] is 0,\n    save; #execute the function save\n    save_positions=(false,false), abstol=1e-3)\nÏµ = -1.35\nfor Q in 0:0.02:maximum_Q_for_Ïµ(system, Ïµ) #for a bunch of initial Qs,\n        if minimum_Ïµ_for(system, P=0, p=0, Q=Q) > Ïµ\n            continue\n        end\n        initial_condition = Point(system, Ïµ=Ïµ, P=0, p=0, Q=Q)\n        integrate(system, uâ‚€=initial_condition,\n            t=10000, callback=callback, save_everystep=false)\n        scatter!(pts)\n        empty!(pts)\n        if !on_github break end #hide\n\n\nend\nmplot\nsavefig(\"poincare_surface.png\");nothing #hide","category":"page"},{"location":"ClassicalDickeExamples/","page":"Classical Dicke","title":"Classical Dicke","text":"(Image: )","category":"page"},{"location":"ClassicalDickeExamples/#Drawing-a-Lyapunov-exponent-map","page":"Classical Dicke","title":"Drawing a Lyapunov exponent map","text":"","category":"section"},{"location":"ClassicalDickeExamples/","page":"Classical Dicke","title":"Classical Dicke","text":"Let us plot the Lyapunov exponents for the PoincarÃ© map of the previous example.","category":"page"},{"location":"ClassicalDickeExamples/","page":"Classical Dicke","title":"Classical Dicke","text":"using Dicke, Dicke.ClassicalDicke, Dicke.ClassicalSystems\nusing Plots\nusing DiffEqBase\n\nsystem = ClassicalDickeSystem(Ï‰=0.8, Î³=0.8, Ï‰â‚€=1)\nÏµ = -1.35\n\nresolution = 0.01 #making this smaller will make a smoother plot,\n                  #but it may take time!\nif !on_github resolution = 0.5 end #hide\n\nmaxQ = maximum_Q_for_Ïµ(system,Ïµ) \nmaxP = maximum_P_for_Ïµ(system,Ïµ) \n\nQs = 0.6:resolution:maxQ\nPs = 0.0:resolution:maxP  #we only compute the top half of \n                          #the plane, and later mirror it\n\n#this matrix contains NaNs (outside of bounds) and tuples [Î»,n] \n#(inside of bounds), where Î» is an average of all the Lyapunov \n#exponents of the n trajectories that have passed through that square\nmatrix = [if minimum_Ïµ_for(system, P=P, p=0, Q=Q) > Ïµ \n            NaN else [0.0,0] end \n                for Q in Qs, P in Ps] \n\npts = Tuple{Float64, Float64}[] #a list of points (Q,P) for temporary storage\n\nfunction save(state) #this function saves (Q,P) to pts if q = qâ‚Š (and not qâ‚‹).\n    if q_sign(system,state.u,Ïµ) == + \n        Q,q,P,p = state.u \n        push!(pts, (Q,P))  \n    end                     \nend\ncallback=ContinuousCallback((x, t, _) -> x[4], #when p=x[4] is 0,\n    save; #execute the function save\n    save_positions=(false,false), abstol=1e-3)\n#an auxiliary function, which gives the index k so that r[k] â‰¥ v >r[k]\nfunction index_of_subinterval(v,r) \n    if r[end] <v\n        return length(r)\n    end\n    if v < r[1] \n        return 1\n    end\n    return Int(round(((v-r[1])/(r[end]-r[1]))*(length(r)-1) +1))\nend\n#we iterate over the matrix and the values of Q,P\nfor ((Q,P),element) in zip(Iterators.product(Qs,Ps),matrix)\n    #if we are out of bounds or we have information on this Lyapunov exponent,\n    if element===NaN || element[2] > 0 \n        continue #we skip\n    end\n    \n    #the following 4 lines will populate pts with all the points (mQ,mP) in the \n    #PoincarÃ© map that the trajectory starting at (Q,P) passes through.\n    empty!(pts)\n    push!(pts,(Q,P))\n    point  = Point(system, Q=Q, P=P, p=0, Ïµ=Ïµ)\n    Î» = lyapunov_exponent(system, \n        t = 5000, \n        uâ‚€ = point, \n        verbose = false, #hide\n        tol=if !on_github 1e-3   else 1e-12 end, #hide\n        callback = callback)\n    \n    \n    for (mQ,mP) in pts\n        #we save the Lyapunov into all of the squares that the trajectory visited.\n        el = matrix[index_of_subinterval(mQ,Qs),index_of_subinterval(abs(mP),Ps)]\n        #if we are inside bounds\n        if el !== NaN\n           \n            el[1] = (el[1]*el[2] + Î»)/(el[2] + 1)  #we update the average\n            el[2] += 1 #we update the count\n        end\n    end\n    if !on_github break end #hide\nend\n\nmat=transpose([v[1] for v in matrix]) #we take the average Lyapunovs, and transpose\n#because heatmap takes transposed matrices.\n\nmat=vcat(mat[end:-1:2,1:end], mat) #mirror in P\nPs=vcat(-Ps[end:-1:2], Ps) #update Ps with negative values\n\nheatmap(Qs, Ps, mat, xlabel=\"Q\", ylabel=\"P\", size=(550,500))\nsavefig(\"lyapunov_map.svg\");nothing #hide","category":"page"},{"location":"ClassicalDickeExamples/","page":"Classical Dicke","title":"Classical Dicke","text":"(Image: )","category":"page"},{"location":"ClassicalDickeExamples/","page":"Classical Dicke","title":"Classical Dicke","text":"It looks very similar to the PoincarÃ© map of the previous example! Notice how there are regular (black) and chaotic (colored) regions.","category":"page"},{"location":"DickeHusimiProjectionsExamples/#Examples-for-DickeHusimiProjections","page":"Dicke Husimi Projections","title":"Examples for DickeHusimiProjections","text":"","category":"section"},{"location":"PhaseSpaces/#Dicke.PhaseSpaces","page":"PhaseSpaces","title":"Dicke.PhaseSpaces","text":"","category":"section"},{"location":"PhaseSpaces/","page":"PhaseSpaces","title":"PhaseSpaces","text":"Modules = [Dicke.PhaseSpaces]\nOrder   = [:type,:function]","category":"page"},{"location":"PhaseSpaces/#Dicke.PhaseSpaces.P_of_Î¸Ï†-Tuple{Real, Real}","page":"PhaseSpaces","title":"Dicke.PhaseSpaces.P_of_Î¸Ï†","text":"function P_of_Î¸Ï†(Î¸,Ï†)\n\nReturns\n\n    P=- sqrt2 (1 - cos(theta))sin(phi)\n\n\n\n\n\n","category":"method"},{"location":"PhaseSpaces/#Dicke.PhaseSpaces.Q_of_Î¸Ï†-Tuple{Real, Real}","page":"PhaseSpaces","title":"Dicke.PhaseSpaces.Q_of_Î¸Ï†","text":"function Q_of_Î¸Ï†(Î¸,Ï†)\n\nReturns\n\n    Q=sqrt2 (1 - cos(theta))cos(phi)\n\n\n\n\n\n","category":"method"},{"location":"PhaseSpaces/#Dicke.PhaseSpaces.arc_between_QP-NTuple{4, Real}","page":"PhaseSpaces","title":"Dicke.PhaseSpaces.arc_between_QP","text":"function arc_between_QP(Q1,P1,Q2,P2)\n\nReturns \n\n    arc_between_Î¸Ï†(Î¸_of_QP(Q1,P1),Ï†_of_QP(Q1,P1),Î¸_of_QP(Q2,P2),Ï†_of_QP(Q2,P2)).\n\n\n\n\n\n","category":"method"},{"location":"PhaseSpaces/#Dicke.PhaseSpaces.arc_between_Î¸Ï†-NTuple{4, Real}","page":"PhaseSpaces","title":"Dicke.PhaseSpaces.arc_between_Î¸Ï†","text":"function arc_between_Î¸Ï†(Î¸1,Ï†1,Î¸2,Ï†2)\n\nReturns \n\n    Theta = arccos(cos(theta_1)cos(theta_2)+ sin(theta_1)sin(theta_2)cos(phi_1 - phi_2))\n\n\n\n\n\n","category":"method"},{"location":"PhaseSpaces/#Dicke.PhaseSpaces.jx-Tuple{Real, Real}","page":"PhaseSpaces","title":"Dicke.PhaseSpaces.jx","text":"function jx(Q,P)\n\nReturns\n\n    j_x = sin(theta(QP))cos(phi(QP))\n\n\n\n\n\n","category":"method"},{"location":"PhaseSpaces/#Dicke.PhaseSpaces.jy-Tuple{Real, Real}","page":"PhaseSpaces","title":"Dicke.PhaseSpaces.jy","text":"function jy(Q,P)\n\nReturns \n\n    j_y = sin(theta(QP))sin(phi(QP))\n\n\n\n\n\n","category":"method"},{"location":"PhaseSpaces/#Dicke.PhaseSpaces.jz-Tuple{Real, Real}","page":"PhaseSpaces","title":"Dicke.PhaseSpaces.jz","text":"function jz(Q,P)\n\nReturns\n\n    j_z = -  cos(theta(QP))\n\nwhere textarctan2 is the 2-argument arctangent.\n\n\n\n\n\n","category":"method"},{"location":"PhaseSpaces/#Dicke.PhaseSpaces.Î¸_of_QP-Tuple{Real, Real}","page":"PhaseSpaces","title":"Dicke.PhaseSpaces.Î¸_of_QP","text":"function Î¸_of_QP(Q,P)\n\nReturns\n\n    theta =- arccos(1 - fracQ^2 + P^22)\n\n\n\n\n\n","category":"method"},{"location":"PhaseSpaces/#Dicke.PhaseSpaces.Ï†_of_QP-Tuple{Real, Real}","page":"PhaseSpaces","title":"Dicke.PhaseSpaces.Ï†_of_QP","text":"function Ï†_of_QP(Q,P)\n\nReturns\n\n    phi =- textarctan2(-PQ)in 02 pi \n\nwhere \\text{arctan2} is the 2-argument arctangent.\n\n\n\n\n\n","category":"method"},{"location":"ClassicalDicke/#Dicke.ClassicalDicke","page":"ClassicalDicke","title":"Dicke.ClassicalDicke","text":"","category":"section"},{"location":"ClassicalDicke/","page":"ClassicalDicke","title":"ClassicalDicke","text":"Modules = [Dicke.ClassicalDicke]\nOrder   = [:type,:function]","category":"page"},{"location":"ClassicalDicke/#Dicke.ClassicalDicke.ClassicalDickeSystem","page":"ClassicalDicke","title":"Dicke.ClassicalDicke.ClassicalDickeSystem","text":"struct ClassicalDickeSystem <: ClassicalSystems.ClassicalSystem\n\nInstance of ClassicalDicke.ClassicalDickeSystem which represents the classical Dicke model with the given parameters Ï‰_0, Ï‰, and Î³. See Eq. (5) of Ref. [10]. To generate this struct, use the constructor\n\nClassicalDickeSystem(;Ï‰â‚€::Real,Ï‰::Real,Î³::Real)\n\nFor example, system = ClassicalDickeSystem(;Ï‰â‚€=1, Ï‰=1, Î³=1).\n\nThis struct may be passed to all functions in this module that require an instance of ClassicalDicke.ClassicalDickeSystem, as well as functions in other modules that require the abstract ClassicalSystems.ClassicalSystem,  such as  ClassicalSystems.integrate.\n\n\n\n\n\n","category":"type"},{"location":"ClassicalDicke/#Dicke.ClassicalDicke.Point-Tuple{Dicke.ClassicalDicke.ClassicalDickeSystem}","page":"ClassicalDicke","title":"Dicke.ClassicalDicke.Point","text":"function Point(system::ClassicalSystems.ClassicalSystem;Q,P,p,Ïµ,signo::Union{typeof(-),typeof(+)}=+)\n\nReturns a list [Q,q,P,p], where q is calculated with ClassicalDicke.q_of_Ïµ. See that function for details on the arguments. If there are no solutions for q, an error is raised.\n\n\n\n\n\n","category":"method"},{"location":"ClassicalDicke/#Dicke.ClassicalDicke.PointÎ¸Ï†-Tuple{}","page":"ClassicalDicke","title":"Dicke.ClassicalDicke.PointÎ¸Ï†","text":"function PointÎ¸Ï†(;Î¸,Ï†,q,p)\n\nReturns a list [Q,q,P,p], where Q and P are calculated from Î¸ and Ï† using PhaseSpaces.Q_of_Î¸Ï† and  PhaseSpaces.P_of_Î¸Ï†.\n\n\n\n\n\n","category":"method"},{"location":"ClassicalDicke/#Dicke.ClassicalDicke.classicalPathRandomSampler-Tuple{Dicke.ClassicalDicke.ClassicalDickeSystem}","page":"ClassicalDicke","title":"Dicke.ClassicalDicke.classicalPathRandomSampler","text":"function classicalPathRandomSampler(system::ClassicalDickeSystem;Ïµ,dt=3)\n\nThis function returns a function sample(), which produces random points within the classical energy shell at energy Ïµ.  This only works at energy shells where the classical dynamics are ergodic. The function sample() returns points from a fixed chaotic trajectory picked at random separated by a fixed time interval  dt.\n\nArguments:\n\nsystem should be generated with ClassicalDicke.ClassicalDickeSystem.\nÏµ is the scaled energy Ïµ=Ej of the energy shell from where to sample.\ndt is the fixed time interval that separates the points that are returned by sample().\n\n\n\n\n\n","category":"method"},{"location":"ClassicalDicke/#Dicke.ClassicalDicke.density_of_states-Tuple{Dicke.ClassicalDicke.ClassicalDickeSystem}","page":"ClassicalDicke","title":"Dicke.ClassicalDicke.density_of_states","text":"function density_of_states(system::ClassicalDickeSystem;j,Ïµ)\n\nReturns the semiclassical density of states (DoS) Î½(Ïµ), in units of 1Ïµ. This is computed with an expression similar to Eq. (19) of Ref. [2], where we add an additional factor of j to have units of 1Ïµ instead of 1E, and the integral is performed with a change of variable.\n\nArguments:\n\nsystem should be generated with ClassicalDicke.ClassicalDickeSystem.\nj is the value of j\nÏµ is the scaled energy Ïµ=Ej\n\nSee Plotting the density of states for an example.\n\n\n\n\n\n","category":"method"},{"location":"ClassicalDicke/#Dicke.ClassicalDicke.discriminant_of_q_solution-Tuple{Dicke.ClassicalDicke.ClassicalDickeSystem}","page":"ClassicalDicke","title":"Dicke.ClassicalDicke.discriminant_of_q_solution","text":"function discriminant_of_q_solution(system::ClassicalDickeSystem; Q,P,p,Ïµ)\n\nReturns the discriminant of the second degree equation in q given by\n\n    h_textcl(QqPp)=epsilon\n\nwhere h_textcl is given by Eq. (5) of Ref. [10].\n\nArguments:\n\nsystem should be generated with ClassicalDicke.ClassicalDickeSystem.\nQ, P, p, and Ïµ are the values of Q, P, p, and epsilon, respectively.\n\n\n\n\n\n","category":"method"},{"location":"ClassicalDicke/#Dicke.ClassicalDicke.energy_shell_volume-Tuple{Dicke.ClassicalDicke.ClassicalDickeSystem, Any}","page":"ClassicalDicke","title":"Dicke.ClassicalDicke.energy_shell_volume","text":"function energy_shell_volume(system::ClassicalDickeSystem;Ïµ)\n\nReturns the volume of the classical energy shell in the phase space, that is, mathcalV(mathcalM_Ïµ) in Eq. (27) of Ref. [9].\n\nArguments:\n\nsystem should be generated with ClassicalDicke.ClassicalDickeSystem.\nÏµ is the scaled energy Ïµ=Ej\n\n\n\n\n\n","category":"method"},{"location":"ClassicalDicke/#Dicke.ClassicalDicke.energy_width_of_coherent_state-Tuple{Dicke.ClassicalDicke.ClassicalDickeSystem, Any, Real}","page":"ClassicalDicke","title":"Dicke.ClassicalDicke.energy_width_of_coherent_state","text":"function energy_width_of_coherent_state(system::ClassicalDickeSystem,x,j::Real)\n\nReturns the energy width sigma of the coherent state left  mathbfxright rangle, in units of epsilon. This quantity is given by sigma_Dj with sigma_D as in App. A of Ref. [5].\n\nArguments:\n\nsystem should be generated with ClassicalDicke.ClassicalDickeSystem.\nx is the coordinate mathbfx of the coherent state in the format [Q,q,P,p].\nj is the value of j.\n\n\n\n\n\n","category":"method"},{"location":"ClassicalDicke/#Dicke.ClassicalDicke.hamiltonian-Tuple{Dicke.ClassicalDicke.ClassicalDickeSystem}","page":"ClassicalDicke","title":"Dicke.ClassicalDicke.hamiltonian","text":"function hamiltonian(system::ClassicalDickeSystem)\n\nReturns a classical Hamiltonian function h(x) where x=[Q,q,P,p], which is given by Eq. (5) of Ref. [10].\n\nArguments:\n\nsystem should be generated with ClassicalDicke.ClassicalDickeSystem.\n\n\n\n\n\n","category":"method"},{"location":"ClassicalDicke/#Dicke.ClassicalDicke.maximum_P_for_Ïµ-Tuple{Dicke.ClassicalDicke.ClassicalDickeSystem, Any}","page":"ClassicalDicke","title":"Dicke.ClassicalDicke.maximum_P_for_Ïµ","text":"function maximum_P_for_Ïµ(system::ClassicalDickeSystem,Ïµ)\n\nComputes the maximum value of the parameter P accessible to the system at energy epsilon.\n\nArguments:\n\nsystem should be generated with ClassicalDicke.ClassicalDickeSystem.\nÏµ is the scaled energy Ïµ=Ej.\n\n\n\n\n\n","category":"method"},{"location":"ClassicalDicke/#Dicke.ClassicalDicke.maximum_Q_for_Ïµ-Tuple{Dicke.ClassicalDicke.ClassicalDickeSystem, Any}","page":"ClassicalDicke","title":"Dicke.ClassicalDicke.maximum_Q_for_Ïµ","text":"function maximum_Q_for_Ïµ(system::ClassicalDickeSystem,Ïµ)\n\nSee ClassicalDicke.maximum_P_for_Ïµ.\n\n\n\n\n\n","category":"method"},{"location":"ClassicalDicke/#Dicke.ClassicalDicke.minimum_energy-Tuple{Dicke.ClassicalDicke.ClassicalDickeSystem}","page":"ClassicalDicke","title":"Dicke.ClassicalDicke.minimum_energy","text":"function minimum_energy(system::ClassicalDickeSystem)\n\nReturns the energy of the ground-state coordinate given by ClassicalDicke.minimum_energy_point.\n\nArguments:\n\nsystem should be generated with ClassicalDicke.ClassicalDickeSystem.\n\nNote: This function currently only works for the supperadiant phase.\n\n\n\n\n\n","category":"method"},{"location":"ClassicalDicke/#Dicke.ClassicalDicke.minimum_energy_point","page":"ClassicalDicke","title":"Dicke.ClassicalDicke.minimum_energy_point","text":"function minimum_energy_point(system::ClassicalDickeSystem,Qsign::Union{typeof(-),typeof(+)}=+)\n\nReturns the ground-state coordinate, that is, mathbfx_textGS below Eq. (7) of Ref. [10].\n\nArguments:\n\nsystem should be generated with ClassicalDicke.ClassicalDickeSystem.\nQsign toggles the sign of the Q coordinate, that is, + for mathbfx_textGS and  - for widetildemathbfx_textGS.\n\nNote: This function currently only works for the superradiant phase.\n\n\n\n\n\n","category":"function"},{"location":"ClassicalDicke/#Dicke.ClassicalDicke.minimum_Ïµ_for-Tuple{Dicke.ClassicalDicke.ClassicalDickeSystem}","page":"ClassicalDicke","title":"Dicke.ClassicalDicke.minimum_Ïµ_for","text":"function minimum_Ïµ_for(system::ClassicalDickeSystem;Q=:nothing,q=:nothing,P=:nothing,p=:nothing)\n\nReturns the minimum energy epsilon when constraining the system to three fixed values of the coordinates Q, q, P, p.\n\nArguments:\n\nsystem should be generated with ClassicalDicke.ClassicalDickeSystem.\nYou may pass either (QqP) or (qPp). The other combinanations are not implemented.\n\nThis function can be especially useful to draw contours of the available phase space (see Drawing contours of the available phase space)\n\n\n\n\n\n","category":"method"},{"location":"ClassicalDicke/#Dicke.ClassicalDicke.normal_frequency","page":"ClassicalDicke","title":"Dicke.ClassicalDicke.normal_frequency","text":"function normal_frequency(system::ClassicalDickeSystem,signo::Union{typeof(-),typeof(+)}=+)\n\nReturns the ground-state normal frequency, that is, Omega_epsilon_textGS^AB at the bottom of page 3 of Ref. [10].\n\nArguments:\n\nsystem should be generated with ClassicalDicke.ClassicalDickeSystem.\nsigno is - for Omega^A and + for Omega^B.\n\nNote: This function currently only works for the supperadiant phase.\n\n\n\n\n\n","category":"function"},{"location":"ClassicalDicke/#Dicke.ClassicalDicke.phase_space_dist_squared-Tuple{Any, Any}","page":"ClassicalDicke","title":"Dicke.ClassicalDicke.phase_space_dist_squared","text":"function phase_space_dist_squared(x,y)\n\nReturns the phase-space distance d_mathcalM(mathbfxmathbfy) (See App. C of Ref [10]), where x and y are in the form [Q,q,P,p].\n\n\n\n\n\n","category":"method"},{"location":"ClassicalDicke/#Dicke.ClassicalDicke.q_of_Ïµ-Tuple{Dicke.ClassicalDicke.ClassicalDickeSystem}","page":"ClassicalDicke","title":"Dicke.ClassicalDicke.q_of_Ïµ","text":"function q_of_Ïµ(system::ClassicalDickeSystem;Q,P,p,Ïµ,signo::Union{typeof(-),typeof(+)}=+,returnNaNonError=true)\n\nReturns the solutions q_pm of the second degree equation in q given by\n\n    h_textcl(QqPp)=epsilon\n\nwhere h_textcl is given by Eq. (5) of Ref. [10].\n\nArguments:\n\nsystem should be generated with ClassicalDicke.ClassicalDickeSystem.\nQ, P, p, and Ïµ are values of Q, P, p, and epsilon, respectively.\nsigno is + for q_+ and - for q_-\nIf returnNaNonError is true, then NaN is returned if there are no solutions. If it is false, and error is raised.\n\n\n\n\n\n","category":"method"},{"location":"ClassicalDicke/#Dicke.ClassicalDicke.q_sign","page":"ClassicalDicke","title":"Dicke.ClassicalDicke.q_sign","text":"function q_sign(system::ClassicalDickeSystem,x,Ïµ=hamiltonian(system)(x))\n\nReturns the sign of the root of the second degree equation in q given by\n\n    h_textcl(QqPp)=epsilon\n\nThat is, this function returns + if q=x[2] â‰ˆ q_of_Ïµ(system;Q=x[1],P=x[3],p=x[4],Ïµ=Ïµ,signo=+) and returns - if q=x[2] â‰ˆ q_of_Ïµ(system;Q=x[1],P=x[3],p=x[4],Ïµ=Ïµ,signo=-).\n\nArguments:\n\nsystem should be generated with ClassicalDicke.ClassicalDickeSystem.\nx is a vector in the form [Q,q,P,p].\nÏµ should be the energy of x. If this is not passed, it is computed using hamiltonian(system). \n\n\n\n\n\n","category":"function"},{"location":"DickeBCE/#Dicke.DickeBCE","page":"DickeBCE","title":"Dicke.DickeBCE","text":"","category":"section"},{"location":"DickeBCE/","page":"DickeBCE","title":"DickeBCE","text":"Modules = [Dicke.DickeBCE]\nOrder   = [ :type,:function]","category":"page"},{"location":"DickeBCE/#Dicke.DickeBCE.QuantumDickeSystem","page":"DickeBCE","title":"Dicke.DickeBCE.QuantumDickeSystem","text":"mutable struct QuantumDickeSystem\n\nThis object represents the quantum Dicke model. It stores the parameters of the system, and it may be passed to multiple functions in this module. To generate it, use\n\nfunction QuantumDickeSystem(classical_system::ClassicalDicke.ClassicalDickeSystem;\n    j::Real,\n    Nmax::Union{Integer,Nothing}=nothing)\n\nArguments:\n\nclassical_system should be generated with ClassicalDicke.ClassicalDickeSystem.\nj is the value of j. It must be a positive half-integer.\nNmax - 1 is the maximum excitation of the modified bosonic sector in the efficient coherent basis (see [3], [4]). Nmax must be a positive integer.  It may be omitted if there is a saved diagonalization.  In that case, a call to diagonalization will populate this value with the  greatest available in the saved cache.    \n\n\n\n\n\n","category":"type"},{"location":"DickeBCE/#Dicke.DickeBCE.QuantumDickeSystem-Tuple{}","page":"DickeBCE","title":"Dicke.DickeBCE.QuantumDickeSystem","text":"function QuantumDickeSystem(;Ï‰â‚€,Ï‰,Î³,j,Nmax=nothing)\n\nShorthand for  QuantumDickeSystem(ClassicalDicke.ClassicalDickeSystem(Ï‰â‚€=Ï‰â‚€, Ï‰=Ï‰, Î³=Î³), j=j, Nmax=Nmax).\n\n\n\n\n\n","category":"method"},{"location":"DickeBCE/#Dicke.DickeBCE.H_BCE-Tuple{Dicke.DickeBCE.QuantumDickeSystem}","page":"DickeBCE","title":"Dicke.DickeBCE.H_BCE","text":"function H_BCE(system::QuantumDickeSystem)\n\nReturns a sparse matrix corresponding to the Dicke Hamiltonian (See Eq. (1) of [11]) in the efficient coherent basis. (See Ref. [3], [4])\n\nArguments:\n\nsystem should be an instance of DickeBCE.QuantumDickeSystem.\n\n\n\n\n\n","category":"method"},{"location":"DickeBCE/#Dicke.DickeBCE.Husimi-Tuple","page":"DickeBCE","title":"Dicke.DickeBCE.Husimi","text":"function Husimi(args...;kargs...)\n\nComputes abs2.(coherentOverlap(args...;kargs...)). The arguments and behavior are the same as coherentOverlap.\n\n\n\n\n\n","category":"method"},{"location":"DickeBCE/#Dicke.DickeBCE.HusimiOfCoherent-Tuple{Dicke.DickeBCE.QuantumDickeSystem, AbstractVector{var\"#s141\"} where var\"#s141\"<:Real, AbstractVector{var\"#s140\"} where var\"#s140\"<:Real}","page":"DickeBCE","title":"Dicke.DickeBCE.HusimiOfCoherent","text":"function HusimiOfCoherent(systemQ::QuantumDickeSystem,\n    x::AbstractArray{<:Real,1},\n    y::AbstractArray{<:Real,1})\n\nReturns  left  left langle mathbfxmiddle  mathbfyright rangle right  ^2.  Equation (3.14b) of Ref. [1] is used for the overlap of the Bloch coherent states.\n\nArguments:\n\nsystemQ should be an instance of DickeBCE.QuantumDickeSystem.\nx and y are vectors in the form [Q, q, P, p].\n\n\n\n\n\n","category":"method"},{"location":"DickeBCE/#Dicke.DickeBCE.Jx-Tuple{Dicke.DickeBCE.QuantumDickeSystem}","page":"DickeBCE","title":"Dicke.DickeBCE.Jx","text":"function Jx(system::QuantumDickeSystem)\n\nReturns a sparse matrix representing the operator hatJ_x in the efficient coherent basis.\n\nArguments:\n\nsystem should be an instance of DickeBCE.QuantumDickeSystem.\n\n\n\n\n\n","category":"method"},{"location":"DickeBCE/#Dicke.DickeBCE.Jz-Tuple{Dicke.DickeBCE.QuantumDickeSystem}","page":"DickeBCE","title":"Dicke.DickeBCE.Jz","text":"function Jz(system::QuantumDickeSystem)\n\nReturns a sparse matrix representing the operator hatJ_z in the efficient coherent basis.\n\nArguments:\n\nsystem should be an instance of DickeBCE.QuantumDickeSystem.\n\n\n\n\n\n","category":"method"},{"location":"DickeBCE/#Dicke.DickeBCE.Wigner-Tuple{Dicke.DickeBCE.QuantumDickeSystem, AbstractArray{var\"#s138\", N} where {var\"#s138\"<:Complex, N}, Vector{var\"#s137\"} where var\"#s137\"<:(AbstractVector{var\"#s82\"} where var\"#s82\"<:Real)}","page":"DickeBCE","title":"Dicke.DickeBCE.Wigner","text":"function Wigner(systemQ::QuantumDickeSystem,\n    state::AbstractArray{<:Number},\n    points::Vector{<:AbstractVector{<:Real}})\n\nEvaluates the Wigner function of state (which is a vector in the BCE) in all points = [[Q1,q1,P1,p1], [Q2,q2,P2,p2], ...], returning an Array with the results.\n\nNote: This function has not been thoroughly tested. It is based on Ref. [7].\n\n\n\n\n\n","category":"method"},{"location":"DickeBCE/#Dicke.DickeBCE.WignerProjQP-Tuple{Dicke.DickeBCE.QuantumDickeSystem, AbstractArray{var\"#s140\", N} where {var\"#s140\"<:Number, N}, Vector{var\"#s139\"} where var\"#s139\"<:(AbstractVector{var\"#s138\"} where var\"#s138\"<:Real)}","page":"DickeBCE","title":"Dicke.DickeBCE.WignerProjQP","text":"function WignerProjQP(systemQ::QuantumDickeSystem,\n    state::AbstractArray{<:Number},\n    ptsqp::Vector{<:AbstractVector{<:Real}})\n\nEvaluates Wigner function, integrated over the atomic variables QP, of state  in all ptsqp = [[q1,p1], [q2,p2], ...], returning an array with the results.\n\nNote: This function has not been thoroughly tested. It is based on Ref. [7].\n\n\n\n\n\n","category":"method"},{"location":"DickeBCE/#Dicke.DickeBCE.WignerProjqp-Tuple{Dicke.DickeBCE.QuantumDickeSystem, AbstractArray{var\"#s4\", N} where {var\"#s4\"<:(AbstractArray{var\"#s3\", N} where {var\"#s3\"<:Complex, N}), N}, Vector{var\"#s2\"} where var\"#s2\"<:(AbstractVector{var\"#s389\"} where var\"#s389\"<:Real)}","page":"DickeBCE","title":"Dicke.DickeBCE.WignerProjqp","text":"function WignerProjqp(systemQ::QuantumDickeSystem,\n    states::AbstractArray{<:AbstractArray{<:Number}},\n    ptsQP::Vector{<:AbstractVector{<:Real}};\n    show_progress::Bool=true)\n\nEvaluates Wigner function, integrated over the bosonic variables qp, of each of the states in states  (which is a vector of complex vectors)  in all ptsQP = [[Q1,P1], [Q2,P2], ...], returning an array with the results. See this example. If show_progress = true it shows a progress bar.\n\nNote: This function has not been thoroughly tested. It is based on Ref. [7].\n\n\n\n\n\n","category":"method"},{"location":"DickeBCE/#Dicke.DickeBCE.coherentBCE!-Tuple{Dicke.DickeBCE.QuantumDickeSystem, AbstractVector{var\"#s139\"} where var\"#s139\"<:Real, AbstractVector{var\"#s138\"} where var\"#s138\"<:Complex}","page":"DickeBCE","title":"Dicke.DickeBCE.coherentBCE!","text":"function coherentBCE!(system::QuantumDickeSystem,\n            x::AbstractArray{<:Real,1},\n            data::AbstractVector{<:Number};\n            normwarning=0.99,\n            add_state_to_data::Bool=false,\n            extra_phase::Complex=1.0+0im,\n            tol::Real=1e-6)\n\nThis function computes the coefficients of a coherent state centered at  x in the BCE, and stores the result in data. (See Ref. [14])\n\nArguments:\n\nsystem should be an instance of DickeBCE.QuantumDickeSystem.\nx is a vector with the coordinates [Q, q, P, p].\ndata should be a complex vector of length dimension(systemQ).\nnormwarning is a tolerance (defaults to 0.99). If the norm of the resulting coherent state is below this number, a warning will be thrown. This usually happens if Nmax is too small for the energy regime you are working on.\nadd_state_to_data is a boolean. If it is true, the coefficients will be added to data. If it is false (default), this function will override any preexisting values in `data. This is useful if you want to add many coherents states together without having to allocate that much memory.\nadd_state_to_data is a boolean. If true, the coefficients will be added to data, and if false (default), this function will override any preexisting values in `data.    \nextra_phase is a complex number that multiplies the resulting state overall.  Defaults to 1.\ntol is a numerical tolerance. If tol=0, then all the coefficients all computed. However, if Îµ = 1 -  tol > 0.0, then a some coefficients at the tail of the distribution and whose squared norm sum does not exceed Îµ, will be treated as 0.0. This allows to  significally reduce computation time, but introduces a numerical error of order Îµ. The default is 1e-6. See this example and Ref. [8].\n\n\n\n\n\n","category":"method"},{"location":"DickeBCE/#Dicke.DickeBCE.coherentBCE-Tuple{Dicke.DickeBCE.QuantumDickeSystem, AbstractVector{var\"#s141\"} where var\"#s141\"<:Real}","page":"DickeBCE","title":"Dicke.DickeBCE.coherentBCE","text":"function coherentBCE(system::QuantumDickeSystem,\n    x::AbstractVector{<:Real};\n    normwarning::Real=0.99,\n    extra_phase::Complex=1.0+0im,\n    tol::Real=0.0)\n\nCalls coherentBCE! passing data as a new vector and returns the result.\n\n\n\n\n\n","category":"method"},{"location":"DickeBCE/#Dicke.DickeBCE.coherentOverlap-Tuple{Dicke.DickeBCE.QuantumDickeSystem, AbstractVector{var\"#s82\"} where var\"#s82\"<:Real, AbstractMatrix{var\"#s81\"} where var\"#s81\"<:Number}","page":"DickeBCE","title":"Dicke.DickeBCE.coherentOverlap","text":"function coherentOverlap(systemQ::QuantumDickeSystem,\n    x::AbstractVector{<:Real},\n    states::AbstractMatrix{<:Number};\n    tol::Real=1e-6,\n    normwarning::Real=0.99,\n    datacache::Union{AbstractVector{<:Complex},Nothing}=nothing)\n\nSame as coherentOverlap(..., state,...) below, but instead of one state, it allows states to be a matrix with multiple states as columns. It is functionally equivalent to\n\n[coherentOverlap(..., states[:,k], ...) for k in 1:size(states)[2]]\n\nbut it is (much) faster. The result is stored in datacache if provided.\n\n\n\n\n\n","category":"method"},{"location":"DickeBCE/#Dicke.DickeBCE.coherentOverlap-Tuple{Dicke.DickeBCE.QuantumDickeSystem, AbstractVector{var\"#s82\"} where var\"#s82\"<:Real, AbstractVector{var\"#s81\"} where var\"#s81\"<:Number}","page":"DickeBCE","title":"Dicke.DickeBCE.coherentOverlap","text":"function coherentOverlap(systemQ::QuantumDickeSystem,\n    x::AbstractVector{<:Real},\n    state::AbstractVector{<:Number};\n    tol::Real=1e-6,\n    normwarning::Real=0.99,\n    datacache::Union{AbstractArray{Complex{Float64},1},Nothing}=nothing)\n\nReturns  the overlap left langle mathbfxmiddle  textstate right rangle, where left  mathbfx right rangle is a coherent state centered at x.\n\nArguments:\n\nsystemQ should be an instance of DickeBCE.QuantumDickeSystem.\nx is a vector in the form [Q, q, P, p].\nstate is a vector representing left  textstate right rangle in the BCE.\ntol is a numerical tolerance. If tol=0, then all the products of coefficients are computed. However, if Îµ = 1 -  tol > 0.0, then a some coefficients of the coherent state at the tail of the distribution and whose squared norm sum does not exceed Îµ, will be treated as 0.0. This allows to  significally reduce computation time, but introduces a numerical error of order Îµ. The default is 1e-6. See this example  and Ref. [8].\nnormwarning is a tolerance (defaults to 0.99). If the norm of the coherent  state is below this number, a warning will be thrown.  This usually happens if Nmax is too small for the energy regime you are working on.\ndatacache in an array where to store the result, or nothing for the result to be returned. \n\n\n\n\n\n","category":"method"},{"location":"DickeBCE/#Dicke.DickeBCE.diagonalization-Tuple{Dicke.DickeBCE.QuantumDickeSystem}","page":"DickeBCE","title":"Dicke.DickeBCE.diagonalization","text":"function diagonalization(systemQ::QuantumDickeSystem;\n        load_cache = true,\n        save_cache = true,\n        cache_folder = joinpath(homedir(),\"dicke_diagonalizations\"),\n        maxÏµ::Real = 5.0,\n        onlyload::Union{AbstractVector{<:Integer},Nothing} = nothing,\n        only_eigenenergies = false,\n        verbose::Bool = true,\n        converged_tolerance=1e-3)\n\nIf load_cache = false or there are no saved diagonalizations in cache_folder, diagonalizes the Dicke Hamiltonian up to a maximum energy maxÏµ. The resulting eigenstates  are guaranteed to be converged, with a tolerance determined by converged_tolerance. Numerical degeneracies are also corrected, to ensure that the eigenstates have parity +1 or -1. If only_eigenenergies is false (default), a tuple (eigenenergies,eigenstates) is returned, where eigenenergies is real vector containing the eigenenergies and eigenstates is a real matrix that contains the eigenstates as columns. \n\nArguments:\n\nsystem should be an instance of DickeBCE.QuantumDickeSystem.\nload_cache is a boolean indicating whether to try to load from cache folder. Defaults to true.\nsave_cache determines if the results of a computed diagonalization are saved to the cache folder. Defaults to true.\ncache_folder is the cache folder where diagonalizations are saved. Default is %HOME%/dicke_diagonalizations\nmaxÏµ is the maximum energy up to which we diagonalize. Keep this number  higher than the maximum converged regime you want.\nonlyload may be a vector of integers, indicating the indices of the eigenstates to load, or the default value, nothing, indicates that all eigenstates should be loaded.\nonly_eigenenergies should be true if you only to load the eigenenergies. Defaults to false (return eigenstates and eigenenergies).\nverbose is true (default) if you want to see info messages.\nconverged_tolerance determines how strict we are in saying that an eigenstate is converged (see [4]). The default value 1e-3 is usually the best.\n\n\n\n\n\n","category":"method"},{"location":"DickeBCE/#Dicke.DickeBCE.dimension-Tuple{Dicke.DickeBCE.QuantumDickeSystem}","page":"DickeBCE","title":"Dicke.DickeBCE.dimension","text":"function dimension(system::QuantumDickeSystem)\n\nReturns the integer (2j + 1)times N_textmax, which gives the dimension of the Hilbert space.\n\n\n\n\n\n","category":"method"},{"location":"DickeBCE/#Dicke.DickeBCE.eigenenergies-Tuple{Dicke.DickeBCE.QuantumDickeSystem}","page":"DickeBCE","title":"Dicke.DickeBCE.eigenenergies","text":"function eigenenergies(systemQ::QuantumDickeSystem;args...)\n\nReturns a vector containing the eigenenergies of the system. These are loaded or computed as in diagonalization. \n\nArguments:\n\nsystem should be an instance of DickeBCE.QuantumDickeSystem.\nargs... â€“ same as in diagonalization.\n\n\n\n\n\n","category":"method"},{"location":"DickeBCE/#Dicke.DickeBCE.eigenstate_parities-Tuple{Dicke.DickeBCE.QuantumDickeSystem, Any}","page":"DickeBCE","title":"Dicke.DickeBCE.eigenstate_parities","text":"function eigenstate_parities(system::QuantumDickeSystem,eigenstates)\n\nReturns a vector of -1s and 1s contaning the parities of all of the eigenstates.\n\nArguments:\n\nsystem should be an instance of DickeBCE.QuantumDickeSystem.\neigenstates is the matrix of eigenstates. (See  diagonalization).\n\n\n\n\n\n","category":"method"},{"location":"DickeBCE/#Dicke.DickeBCE.evolve-Tuple{Union{Real, AbstractArray{var\"#s17\", N} where {var\"#s17\"<:Real, N}}}","page":"DickeBCE","title":"Dicke.DickeBCE.evolve","text":"function evolve(t::Union{Real,AbstractArray{<:Real}};\n    state::AbstractVector{<:Number},\n    eigenstates::AbstractMatrix{<:Number},\n    eigenenergies::AbstractVector{<:Real},\n    normwarning::Real=0.99)\n\nComputes the evolution left  textstate(t)right rangle of state under the Dicke Hamiltonian. The result is returned in the BCE. at the times given.\n\nArguments:\n\nt may be a single time, or a vector of times. In the first case, a vector will be  returned, and in the second, a matrix with the state corresponding to each time as  a column.\nstate is a vector representing the state in the BCE.\neigenstates and eigenenergies are the ones returned by diagonalization.\nnormwarning is a tolerance (defaults to 0.99). If the norm of the state in the eigenbasis is below this number, a warning will be thrown. This usually happens if Nmax is too small for the energy regime you are working on.\n\n\n\n\n\n","category":"method"},{"location":"DickeBCE/#Dicke.DickeBCE.factor_R_of_coherent_state-Tuple{Dicke.DickeBCE.QuantumDickeSystem, AbstractVector{var\"#s16\"} where var\"#s16\"<:Real}","page":"DickeBCE","title":"Dicke.DickeBCE.factor_R_of_coherent_state","text":"function factor_R_of_coherent_state(system::QuantumDickeSystem,\n        x::AbstractVector{<:Real};\n        eigenstates::AbstractMatrix{<:Number},\n        eigenenergies::AbstractVector{<:Real},\n        state::AbstractVector{<:Number} = coherentBCE(system,x))\n\nComputes R for a coherent state, as defined in Eq. (30) of [14].\n\nArguments:\n\nsystem should be an instance of DickeBCE.QuantumDickeSystem.\nx is an array [Q,q,P,p] representing the center of the coherent state.\neigenstates should be a matrix containing the eigenstates as columns.\neigenenergies  is a list containing the eigenenergies.\nstate is a complex vector representing the coherent state left  mathbfx right rangle. If it is not passed, it is computed using DickeBCE.coherentBCE\n\n\n\n\n\n","category":"method"},{"location":"DickeBCE/#Dicke.DickeBCE.participation_ratio-Tuple{AbstractVector{var\"#s81\"} where var\"#s81\"<:Number}","page":"DickeBCE","title":"Dicke.DickeBCE.participation_ratio","text":"function participation_ratio(state::AbstractVector{<:Number};\n    eigenstates::AbstractMatrix{<:Number},\n    eigenenergies::Union{AbstractVector{<:Real},Nothing}=nothing,\n    count_degeneracies::Bool=eigenenergies!=nothing,\n    degentol::Real=1e-5)\n\nReturns the Participation Ratio (PR) of state in the eigenbasis. If count_degeneracies is true, then Eq. (7) of [14] is used. If count_degeneracies is false, then the inverse of Eq. (19) of [14] is used.\n\nArguments:\n\nstate should be a complex vector representing the state in the efficient coherent basis.\neigenstates should be a matrix containing the eigenstates.\neigenenergies should be passed if count_degeneracies is  true. It is a list containing the eigenenergies.\ncount_degeneracies â€“ whether to modify the PR definition to account for degeneracies (see above).  Default is false if eigenenergies is not passed, else it is true.\ndegentol minimum energy separation below which two eigenstates are considered degenerate. Default is 1e-5.\n\n\n\n\n\n","category":"method"},{"location":"DickeBCE/#Dicke.DickeBCE.randomCoherentStatesInEnergyShell-Tuple{Dicke.DickeBCE.QuantumDickeSystem}","page":"DickeBCE","title":"Dicke.DickeBCE.randomCoherentStatesInEnergyShell","text":"function randomCoherentStatesInEnergyShell(\n    systemQ::QuantumDickeSystem;\n    Ïµ::Real,\n    N::Integer,\n    dt::Real=3,\n    tol::Real=1e-6,\n    cachedata::Union{AbstractVector{<:Complex},Nothing}=nothing)\n\nSamples N points from the energy shell at Ïµ using ClassicalDicke.classicalPathRandomSampler, and then constructs the N-cat state of all the coherent states centered at those points. \n\n\n\n\n\n","category":"method"},{"location":"DickeBCE/#Dicke.DickeBCE.randomState!-Tuple{Dicke.DickeBCE.QuantumDickeSystem, AbstractVecOrMat{var\"#s16\"} where var\"#s16\"<:Number}","page":"DickeBCE","title":"Dicke.DickeBCE.randomState!","text":"function randomState!(systemQ::QuantumDickeSystem,\n    data::AbstractVecOrMat{<:Number};\n    kargs...)\n\nGenerates as many random states as columns in data saving the result to data. The general form of the random states in the eigenbasis is left  R right rangle = sum_k c_k left  E_k right rangle, where the c_k are computed using random_câ‚–_generator. You may select only positive or negative parity eigenstates (see below).\n\nArguments\n\nsystemQ should be an instance of DickeBCE.QuantumDickeSystem.\ndata should be a vector or matrix of numbers, where the result is stored. It must have as many columns as random numbers you want and dimension(systemQ) rows.\n\nRequired keyword arguments\n\nPlease pass all the required keyword arguments of random_câ‚–_generator\neigenstates and eigenenergies shoud be passed, being the ones returned by diagonalization.\n\nOptional keyword arguments\n\nAll the optional keyword arguments of random_câ‚–_generator may be passed.\ntol may be a real number which determines the tolerance for the state convergence. A value tol=0 builds the state with all of the eigenstates, and a positive number cuts the tails of the energy envelope up to that number. Higher values are faster,  but decrease precision (Defaults to 1e-6)\nparity may be +, -, or nothing (default). If it is not nothing, the random will be composed of only the eigenstates with this parity.\nparities should be passed if parity is not nothing. It should be a vector of -1s  and 1s containing the parities of all of the eigenstates. If it is not passed, it will be  computed with eigenstate_parities, but this is slow. If you plan to use this function repeatedly, you should precompute parities by calling eigenstate_parities  yourself and then pass it to avoid repeated calls.\n\n\n\n\n\n","category":"method"},{"location":"DickeBCE/#Dicke.DickeBCE.randomState-Tuple{Dicke.DickeBCE.QuantumDickeSystem}","page":"DickeBCE","title":"Dicke.DickeBCE.randomState","text":"function randomState(systemQ::QuantumDickeSystem;\n                    number_of_states=1,\n                    kargs...)\n\nGenerates number_of_states random states, returning them as columns in a matrix (or a vector if number_of_states). kargs are redirected to randomState!: see that function for more details.\n\n\n\n\n\n","category":"method"},{"location":"DickeBCE/#Dicke.DickeBCE.random_câ‚–_generator-Tuple{Dicke.DickeBCE.QuantumDickeSystem}","page":"DickeBCE","title":"Dicke.DickeBCE.random_câ‚–_generator","text":"function random_câ‚–_generator(systemQ::QuantumDickeSystem;\n                            kargs...)\n\nGenerates coefficients to build random states, which are given by\n\n    c_k(epsilon_k) sim e^i theta_k sqrtfracr_krho(epsilon_k)nu(epsilon_k)\n\n(See Refs. [6], [14], and [11]). It returns a function câ‚–(Ïµ;number=1,cache=nothing), which produces n=number coefficients, storing them in cache (an n-vector), if given.\n\nThe parameters of the equation above are determined as follows:\n\nRequired keyword arguments\n\nTo determine  rho(epsilon) above, pass either: \nÏƒ and Ïµ, both real, in which case rho will be taken as a normal distribution centered at Ïµ with standard deviation Ïƒ,\nOR envelope as any of Distributions.UnivariateDistribution.\nTo determine r_k, pass either:\nensemble = :GUE, which takes r_k from an exponential distribution Exponential(0.91) or ensemble = :GOE, which takes r_k from a chi^2 distribution with one degree of freedom,\nOR râ‚–_distribution as any of Distributions.UnivariateDistribution.\nTo determine theta_k, pass either:\nphases = :real, which takes theta_k to be random from  -pi pi  or phases = :complex, which takes theta_k to be uniform in 0 2pi),\nOR ensemble = :GOE, which automatically sets phases = :real, or ensemble = :GUE, which automatically sets phases = :complex.\n\nOptional keyword arguments\n\ndivide_by_DoS is a boolean. If true (default), leaves the density of states, nu(epsilon_k) in the equation above. A value of false removes it.\n\n\n\n\n\n","category":"method"},{"location":"DickeBCE/#Dicke.DickeBCE.survival_probability-Tuple{Union{Real, AbstractArray{var\"#s15\", N} where {var\"#s15\"<:Real, N}}}","page":"DickeBCE","title":"Dicke.DickeBCE.survival_probability","text":"function survival_probability(t::Union{Real,AbstractArray{<:Real}};\n    state::AbstractVector{<:Number},\n    eigenstates::AbstractMatrix{<:Number},\n    eigenenergies::AbstractVector{<:Real},\n    normwarning::Real=0.99)\n\nComputes the survival probability left  left langle textstatemiddle  textstate(t)right rangle right  ^2 at the times given.\n\nArguments:\n\nt may be a single time, or a vector of times. In the first case, a number will be  returned, and in the second, a vector.\nstate is a vector representing the state in the BCE.\neigenstates and eigenenergies are the ones returned by diagonalization.\nnormwarning is a tolerance (defaults to 0.99). If the norm of the state in the eigenbasis is below this number, a warning will be thrown. This usually happens if Nmax is too small for the energy regime you are working on.\n\n\n\n\n\n","category":"method"},{"location":"DickeBCE/#Dicke.DickeBCE.Î _BCE-Tuple{Dicke.DickeBCE.QuantumDickeSystem}","page":"DickeBCE","title":"Dicke.DickeBCE.Î _BCE","text":"function Î _BCE(system::QuantumDickeSystem)\n\nReturns a sparse matrix corresponding to the parity operator hatPi=e^ipi(hata^daggerhata+ hatJ_z + j) in the efficient coherent basis.\n\nArguments:\n\nsystem should be an instance of DickeBCE.QuantumDickeSystem.\n\n\n\n\n\n","category":"method"},{"location":"ClassicalSystems/#Dicke.ClassicalSystems","page":"ClassicalSystems","title":"Dicke.ClassicalSystems","text":"","category":"section"},{"location":"ClassicalSystems/","page":"ClassicalSystems","title":"ClassicalSystems","text":"Modules = [Dicke.ClassicalSystems]\nOrder   = [:function, :type]","category":"page"},{"location":"ClassicalSystems/#Dicke.ClassicalSystems.integrate-Tuple{Dicke.ClassicalSystems.ClassicalSystem}","page":"ClassicalSystems","title":"Dicke.ClassicalSystems.integrate","text":"function integrate(system::ClassicalSystem;t::Real,\n                   uâ‚€::AbstractArray{<:Real, 1},\n                   tâ‚€=0.0::Real,\n                   tol=1e-12::Real,\n                   get_fundamental_matrix::Bool=false,\n                   integrator_alg=TsitPap8(),\n                   use_big_numbers::Bool=false,\n                   integate_backwards::Bool=false,\n                   kargs...)\n\nThis function integrates initial condition uâ‚€ from tâ‚€ to t under the Hamiltonian system determined by system, returning an instance of OrdinaryDiffEq.ODESolution.\n\nArguments:\n\nsystem is an instance of ClassicalSystems.ClassicalSystem.\nuâ‚€ is an array which codifies the initial condition [Q,q,P,p] for ClassicalDicke and [Q,P] for ClassicalLMG.\nt is the start time of the integration.\ntâ‚€ is the start of the integration (defaults to tâ‚€ = 0.0) ClassicalSystems.ClassicalSystem.\ntol is the tolerance for the integration, which determines both abstol and reltol in OrdinaryDiffEq.solve\nget_fundamental_matrix determines whether to also compute the fundametal matrix of the system. If true, the result at each time is an ArrayPartition(x,Î¦), so that x=result.x[2] retrieves the coordinate and Î¨=result.x[2] retrieves the fundamental matrix. Default is false. Note that the integration is consideribly slowed down if this parameter is set to true.\nintegrator_alg is the integration algorithm to use. Defaults to TsitPap8 (Tsitouras-Papakostas 8/7 Runge-Kutta method). See the DifferentialEquations documentation for other options.\nuse_big_numbers forces the integration to be performed with BigFloat instead of Float, allowing for infinite numerical precision, but hindering speed substantially. Defaults to false.\nintegate_backwards tells the integrator to integrate back in time, from -tâ‚€ to -t. Defaults to  false.\nAdditional kargs are passed to OrdinaryDiffEq.solve.\n\n\n\n\n\n","category":"method"},{"location":"ClassicalSystems/#Dicke.ClassicalSystems.lyapunov_exponent-Tuple{Dicke.ClassicalSystems.ClassicalSystem}","page":"ClassicalSystems","title":"Dicke.ClassicalSystems.lyapunov_exponent","text":"function lyapunov_exponent(system::ClassicalSystem;kargs...)\n\nReturns the maximal Lyapunov exponent for system.\n\nArguments\n\nsystem is an instance of ClassicalSystems.ClassicalSystem.\nkargs... are redirected to ClassicalSystems.integrate. In particular, you should pass uâ‚€. The value t is set to 10000 but you may change it: lower values increase speed, higher values increase precision. \n\n\n\n\n\n","category":"method"},{"location":"ClassicalSystems/#Dicke.ClassicalSystems.lyapunov_spectrum-Tuple{Dicke.ClassicalSystems.ClassicalSystem}","page":"ClassicalSystems","title":"Dicke.ClassicalSystems.lyapunov_spectrum","text":"function lyapunov_spectrum(system::ClassicalSystem;kargs...)\n\nSame as ClassicalSystems.lyapunov_exponent, but returns the whole Lyapunov spectrum.\n\n\n\n\n\n","category":"method"},{"location":"ClassicalSystems/#Dicke.ClassicalSystems.ClassicalSystem","page":"ClassicalSystems","title":"Dicke.ClassicalSystems.ClassicalSystem","text":"abstract struct ClassicalSystem\n\nThis abstract object represents a classical system that may be passed to multiple functions in this module. To generate a system, use the subtypes ClassicalDicke.ClassicalDickeSystem or use ClassicalLMG.ClassicalLMGSystem.\n\n\n\n\n\n","category":"type"},{"location":"","page":"The Dicke.jl package","title":"The Dicke.jl package","text":"This package is a result of more than two years of investigation of the Dicke Model. It contains numerical methods that were used in the following publications:","category":"page"},{"location":"","page":"The Dicke.jl package","title":"The Dicke.jl package","text":"Quantum localization measures in phase space.  Physical Review E 103 052214 (2021) DOI: 10.1103/physreve.103.052214\nUbiquitous quantum scarring does not prevent ergodicity.  Nature Communications 12 852 (2021) DOI: 10.1038/s41467-021-21123-5\nQuantum scarring in a spin-boson system: fundamental families of periodic orbits.  New Journal of Physics 23 033045 (2021) DOI: 10.1088/1367-2630/abd2e6\nQuantum vs classical dynamics in a spin-boson system: manifestations of spectral correlations and scarring.  New Journal of Physics 22 063036 (2020) DOI: 10.1088/1367-2630/ab8ef8\nPositive quantum Lyapunov exponents in experimental systems with a regular classical limit.  Physical Review E 101 010202(R) (2020) DOI: 10.1103/PhysRevE.101.010202","category":"page"},{"location":"","page":"The Dicke.jl package","title":"The Dicke.jl package","text":"It is split into several submodules:","category":"page"},{"location":"","page":"The Dicke.jl package","title":"The Dicke.jl package","text":"ClassicalDicke allows to compute classical dynamics of the Dicke model, including a wide range of semiclassical aproximations to quantum properties.\nClassicalSystems provides a general framework for computing classical Hamiltonian dynamics, inlcuding Lyapunov exponents. It is mostly used for the Dicke model, but in principle it can be expanded to other Hamiltonians.\nDickeBCE provides multiple functions for analyzing the quantum Dicke model. It uses an efficient basis known as the Efficient Coherent Basis (BCE). See Refs. above.\nUPOS contains a set of functions to find unstable periodic orbits (UPOs) in the classical Dicke model. (See Ref. 3)\nTruncatedWignerApproximation allows to perform semiclassical calculations using the truncated Wigner approximation (TWA). (See Refs 2,5)\nDickeHusimiProjections contains a set of functions to integrate functions over the classical energy shells of the Dicke Model. It also contains specialized functions to compute these integrals for the Husimi functions of quantum states, which define phase-space localization measures known as RÃ©nyi occupations (See Refs. 1 and 2)\nClassicalLMG provides very basic functions for the classical Lipkin-Meshkov-Glick model. (See Ref. 5)\nPhaseSpaces provides some canonical transformations of the Bloch-Sphere.","category":"page"}]
}
