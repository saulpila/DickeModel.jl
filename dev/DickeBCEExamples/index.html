<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>DickeBCE (Quantum Dicke) ¬∑ DickeModel.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/customcss.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">DickeModel.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">DickeModel.jl</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../ClassicalDickeExamples/">ClassicalDicke</a></li><li class="is-active"><a class="tocitem" href>DickeBCE (Quantum Dicke)</a><ul class="internal"><li><a class="tocitem" href="#Diagonalizing-the-Dicke-Hamiltonian"><span>Diagonalizing the Dicke Hamiltonian</span></a></li><li><a class="tocitem" href="#quantumldoscoherentstateex"><span>Local density of states of a coherent state</span></a></li><li><a class="tocitem" href="#ExampleEfficientHusimiFunctions"><span>Efficient Husimi functions</span></a></li><li><a class="tocitem" href="#wignerfuncexample"><span>Projected Wigner function of a cat state</span></a></li><li><a class="tocitem" href="#Plotting-the-semiclassical-density-of-states"><span>Plotting the semiclassical density of states</span></a></li></ul></li><li><a class="tocitem" href="../EnergyShellProjectionsExamples/">EnergyShellProjections</a></li><li><a class="tocitem" href="../TWAExamples/">TWA</a></li><li><a class="tocitem" href="../UPOsExamples/">UPOs</a></li><li><a class="tocitem" href="../ClassicalLMGExamples/">ClassicalLMG</a></li></ul></li><li><span class="tocitem">Documentation</span><ul><li><a class="tocitem" href="../ClassicalDicke/">ClassicalDicke</a></li><li><a class="tocitem" href="../DickeBCE/">DickeBCE</a></li><li><a class="tocitem" href="../EnergyShellProjections/">EnergyShellProjections</a></li><li><a class="tocitem" href="../TWA/">TWA</a></li><li><a class="tocitem" href="../UPOs/">UPOs</a></li><li><a class="tocitem" href="../ClassicalLMG/">ClassicalLMG</a></li><li><a class="tocitem" href="../ClassicalSystems/">ClassicalSystems</a></li><li><a class="tocitem" href="../PhaseSpaces/">PhaseSpaces</a></li></ul></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>DickeBCE (Quantum Dicke)</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>DickeBCE (Quantum Dicke)</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/saulpila/DickeModel.jl/blob/master/docs/src/DickeBCEExamples.md" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Examples-for-DickeBCE"><a class="docs-heading-anchor" href="#Examples-for-DickeBCE">Examples for DickeBCE</a><a id="Examples-for-DickeBCE-1"></a><a class="docs-heading-anchor-permalink" href="#Examples-for-DickeBCE" title="Permalink"></a></h1><p>The module <a href="../DickeBCE/#DickeModel.DickeBCE"><code>DickeModel.DickeBCE</code></a> works with the quantum Dicke model using a very efficient basis known as the coherent efficient basis (BCE for its acronym in Spanish). See Refs. <a href="../references/#Bastarrachea2014PSa">[4]</a> and <a href="../references/#Bastarrachea2014PSb">[5]</a> for a detailed explanation on how and why it works.  Throughout this examples, we will work with a system size of <code>j = 30</code>, but  using this module you can easily go up to <code>j = 100</code> (as done in Refs. <a href="../references/#Pilatowsky2021">[13]</a>, <a href="../references/#Pilatowsky2021NatCommun">[14]</a>, <a href="../references/#Pilatowsky2021Identification">[15]</a>, <a href="../references/#Villasenor2021">[20]</a>) and beyond.</p><h2 id="Diagonalizing-the-Dicke-Hamiltonian"><a class="docs-heading-anchor" href="#Diagonalizing-the-Dicke-Hamiltonian">Diagonalizing the Dicke Hamiltonian</a><a id="Diagonalizing-the-Dicke-Hamiltonian-1"></a><a class="docs-heading-anchor-permalink" href="#Diagonalizing-the-Dicke-Hamiltonian" title="Permalink"></a></h2><p>Let us start by defining our parameters:</p><pre><code class="language-julia">using DickeModel.DickeBCE, DickeModel.ClassicalDicke
system = QuantumDickeSystem(œâ=1.0, Œ≥=1.0, œâ‚ÇÄ=1.0, j=30, Nmax=120)</code></pre><p>To load the eigenbasis, simply use <a href="../DickeBCE/#DickeModel.DickeBCE.diagonalization"><code>diagonalization</code></a>:</p><pre><code class="language-julia">@time eigenenergies,eigenstates = diagonalization(system)</code></pre><pre class="documenter-example-output">[ Info: Diagonalizing...
[ Info: 3454 converged states were obtained up to œµ=1.1807678467701475.
[ Info: Fixing numerical degeneracies (correcting parity).
449.703669 seconds (233.99 M allocations: 7.604 GiB, 0.47% gc time, 0.62% compilation time)</pre><p>Diagonalizing the Hamiltonian is an expensive operation. For <code>j = 100</code> and <code>Nmax = 300</code> it can take up to a day, but the function <a href="../DickeBCE/#DickeModel.DickeBCE.diagonalization"><code>diagonalization</code></a> saves the result to disk, so the second time you call it with the same parameters it just loads it:</p><pre><code class="language-julia">system = QuantumDickeSystem(œâ=1.0, Œ≥=1.0, œâ‚ÇÄ=1.0, j = 30)
@time eigenenergies,eigenstates =  diagonalization(system)</code></pre><pre class="documenter-example-output">[ Info: Loading diagonalization: Nmax=120
  3.127123 seconds (389.67 k allocations: 695.713 MiB, 1.33% gc time, 0.38% compilation time)</pre><p>Note that we did not have to pass <code>Nmax</code> this time, it loaded it from disk  (see more details on the documentation of <a href="../DickeBCE/#DickeModel.DickeBCE.QuantumDickeSystem"><code>QuantumDickeSystem</code></a>). </p><p>You can change the default folder, or disable caching altogether by passing extra arguments to <a href="../DickeBCE/#DickeModel.DickeBCE.diagonalization"><code>diagonalization</code></a>.</p><p>The resulting <code>eigenstates</code> form a matrix. To get the <span>$k$</span>th eigenstate, simply call <code>state_k = eigenstates[:,k]</code> (or, even better, <code>state_k = @view eigenstates[:,k]</code>, which <a href="https://docs.julialang.org/en/v1/manual/performance-tips/#man-performance-views">avoids unnecessary memory allocations.</a>)</p><h2 id="quantumldoscoherentstateex"><a class="docs-heading-anchor" href="#quantumldoscoherentstateex">Local density of states of a coherent state</a><a id="quantumldoscoherentstateex-1"></a><a class="docs-heading-anchor-permalink" href="#quantumldoscoherentstateex" title="Permalink"></a></h2><p>In this example, we obtain the eigenenergy components of a coherent state. The function <a href="../DickeBCE/#DickeModel.DickeBCE.coherent_state"><code>coherent_state</code></a> will give us a coherent state in the BCE, then we project it into the eigenbasis by left-multiplying by <code>eigenstates&#39;</code>, which is short for  <a href="https://docs.julialang.org/en/v1/stdlib/LinearAlgebra/#Base.adjoint"><code>adjoint</code></a><code>(eigenstates)</code>. Finally, we broadcast the <a href="https://docs.julialang.org/en/v1/manual/functions/#man-vectorized">vectorized version of</a> the function <a href="https://docs.julialang.org/en/v1/base/math/#BaseW.abs2"><code>abs2</code></a> to extract all the coefficients.</p><pre><code class="language-julia">using Plots
using DickeModel.DickeBCE, DickeModel.ClassicalDicke
j = 30
system = QuantumDickeSystem(œâ=1.0, Œ≥=1.0, œâ‚ÇÄ=1.0, j = j, Nmax=120)
eigenenergies,eigenstates = diagonalization(system)

œµ‚Çì = -0.5
x = Point(system, Q=-1, P=0, p=0, œµ=œµ‚Çì)
coh_state = coherent_state(system, x)
coherent_state_eigenbasis = eigenstates&#39;*coh_state
absc‚Çñ¬≤=abs2.(coherent_state_eigenbasis)
œµ‚Çñs = eigenenergies/j


plot(histogram(œµ‚Çñs, weights=absc‚Çñ¬≤,
        ylabel=&quot;Probability density&quot;, xticks=:none,normed=true,nbins=50),

    scatter(œµ‚Çñs, absc‚Çñ¬≤, ylabel=&quot;|c‚Çñ|¬≤&quot;, xlabel=&quot;œµ&quot;),

   size=(700,500), key=false, layout=(@layout [¬∞;¬∞]),
   xlim=(œµ‚Çñs[1],œµ‚Çñs[end]))</code></pre><p><img src="../LDoS_quantum.svg" alt/></p><p>See <a href="../TWAExamples/#semiclassicalLDoS">this example</a> for a semiclassical computation of the envelope of this function.</p><h2 id="ExampleEfficientHusimiFunctions"><a class="docs-heading-anchor" href="#ExampleEfficientHusimiFunctions">Efficient Husimi functions</a><a id="ExampleEfficientHusimiFunctions-1"></a><a class="docs-heading-anchor-permalink" href="#ExampleEfficientHusimiFunctions" title="Permalink"></a></h2><p>The functions <a href="../DickeBCE/#DickeModel.DickeBCE.husimi"><code>DickeBCE.husimi</code></a>,  <a href="../DickeBCE/#DickeModel.DickeBCE.coherent_overlap"><code>DickeBCE.coherent_overlap</code></a>, and <a href="../DickeBCE/#DickeModel.DickeBCE.coherent_state"><code>DickeBCE.coherent_state</code></a> all accept a <code>chop</code> argument, which allows to significally speed up computation time at the cost of slight numerical precision <a href="../references/#Pilatowsky2020Notes">[11]</a>. In this example we show how significant this speedup can be. Let us construct a big system:</p><pre><code class="language-julia">using DickeModel
using DickeModel.DickeBCE
using DickeModel.ClassicalDicke
using LinearAlgebra

j = 600
Nmax = 1200
system = QuantumDickeSystem(œâ‚ÇÄ=1, œâ=1, Œ≥=1, j=j, Nmax=Nmax);</code></pre><p><strong>Do not try to diagonalize such a big system! Your computer üíª might explode üí•!</strong></p><p>For the sake of example, let us construct some random states in a simple manner (although if you are interested in building random states in the eigenbasis, check the function <a href="../DickeBCE/#DickeModel.DickeBCE.random_state"><code>DickeBCE.random_state</code></a> and see <a href="../EnergyShellProjectionsExamples/#ExampleRenyiOccupationsRandomStates">this example</a>).</p><pre><code class="language-julia">n = 3 #how many random vectors
D = dimension(system)
random_vectors = rand(ComplexF64,(D,n))
for i in 1:n
    random_vectors[:,i] /= norm(@view random_vectors[:,i]) #normalize each one
end</code></pre><p><code>random_vectors</code> is a matrix with <code>n</code> columns (states). Let us fix a point in the phase space:</p><pre><code class="language-julia">x = Point(Q=0.6, P=-0.1, p=-0.2, q=-0.8)</code></pre><p>We may call <a href="../DickeBCE/#DickeModel.DickeBCE.husimi"><code>husimi</code></a><code>(system, x, random_vectors)</code>, which will return an array with <code>n</code> elements. The <code>i</code>th element is the result of evaluating the Husimi function  of the <code>i</code>th state (column) at the point <code>x</code>.</p><pre><code class="language-julia-repl">julia&gt; @time husimi(system, x, random_vectors, chop = 0)
 14.924603 seconds (34.10 M allocations: 927.345 MiB, 1.25% gc time, 2.04% compilation time)
3-element Vector{Float64}:
 4.4778213220261675e-7
 2.710877473969897e-7
 5.182098548516507e-8</code></pre><p>By passing <code>chop = 0</code> we are allowing for no optimization. The code has to build all the coefficients of the coherent state and then multiply them by each coefficient in <code>random_vectors</code>. However, if we set <code>chop</code> to be slightly bigger, things will speed up significantly:</p><pre><code class="language-julia-repl">julia&gt; @time husimi(system, x, random_vectors, chop = 1e-14)
  0.072228 seconds (456.54 k allocations: 13.270 MiB, 26.85% compilation time)
3-element Vector{Float64}:
 4.477827437078215e-7
 2.710867756570489e-7
 5.182094999665027e-8</code></pre><p>Note that the results barely changed, but this time it used a lot less memory and time. The <code>chop</code> argument tells the code it can <em>chop</em> a portion of that size off the  tails of the distribution of the coherent state (see Ref. <a href="../references/#Pilatowsky2020Notes">[11]</a> for details).  You loose almost no information, and you gain a lot of time. The default is <code>chop = 1e-6</code>, although you may increase it if you need more precision:</p><pre><code class="language-julia-repl">julia&gt; @time husimi(system, x, random_vectors) #default chop = 1e-6
  0.023821 seconds (194.72 k allocations: 5.249 MiB)
3-element Vector{Float64}:
 4.48910441499923e-7
 2.697814261017752e-7
 5.218962340473051e-8</code></pre><p>That&#39;s fast!</p><h2 id="wignerfuncexample"><a class="docs-heading-anchor" href="#wignerfuncexample">Projected Wigner function of a cat state</a><a id="wignerfuncexample-1"></a><a class="docs-heading-anchor-permalink" href="#wignerfuncexample" title="Permalink"></a></h2><p>Using <a href="../DickeBCE/#DickeModel.DickeBCE.WignerProjqp"><code>DickeBCE.WignerProjqp</code></a>, we may compute the Wigner function of a state, projected onto the atomic plane. We do this for a <a href="https://en.wikipedia.org/wiki/Cat_state#Cat_states_in_single_modes">cat state</a> composed of two coherent states centered at <code>x</code> and <code>y</code>, which, taking advantage of <a href="https://docs.julialang.org/en/v1/manual/unicode-input/">Julia&#39;s Unicode capabilities</a>, we name <code>üê±</code> (write <code>\:cat:</code> + Tab).</p><pre><code class="language-julia">using DickeModel.ClassicalDicke, DickeModel.DickeBCE
system = QuantumDickeSystem(œâ=1.0, Œ≥=1.0, œâ‚ÇÄ=1.0, j=10, Nmax=50)
res=0.025
Qs=Ps=-2:res:2
pts=[[Q,P] for Q in Qs, P in Ps if Q^2+P^2 &lt;= 4]

x = Point(Q=-1.0, P=0, p=0, q=0)
y = Point(Q= 1.0, P=0, p=0, q=0)
üê± = 1/sqrt(2) * (coherent_state(system, x) + coherent_state(system, y))

W=DickeBCE.WignerProjqp(system,
                    [üê±],
                    pts
                    )[1]
d=Dict(zip(pts,W))
function mW(Q,P)
    if [Q,P] in pts
        return d[[Q,P]]
    else
        return NaN
    end
end
heatmap(Qs, Ps, mW, size=(600,600),
    xlabel = &quot;Q&quot;, ylabel = &quot;P&quot;,
    c=cgrad(:bwr, rev = true), clim=(-2.5,2.5))</code></pre><p><img src="../catWigner.svg" alt/></p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The functions for computing Wigner functions are not thoroughly tested nor thoroughly optimized. They are based on these notes <a href="../references/#Pilatowsky2019Notes">[10]</a>, but they have room for improvement.</p></div></div><h2 id="Plotting-the-semiclassical-density-of-states"><a class="docs-heading-anchor" href="#Plotting-the-semiclassical-density-of-states">Plotting the semiclassical density of states</a><a id="Plotting-the-semiclassical-density-of-states-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting-the-semiclassical-density-of-states" title="Permalink"></a></h2><p>Using <a href="../DickeBCE/#DickeModel.DickeBCE.density_of_states"><code>DickeBCE.density_of_states</code></a>, we plot the semiclassical  density of states originally calculated in Ref. <a href="../references/#Bastarrachea2014">[3]</a>. Note that this function does not require diagonalization, so we can have <code>j</code> as large as we want.</p><pre><code class="language-julia">using DickeModel.ClassicalDicke
using DickeModel.DickeBCE

using Plots
system = QuantumDickeSystem(œâ=1, Œ≥=1, œâ‚ÇÄ=1, j=100)

ŒΩ(œµ) = density_of_states(system, œµ)
œµgs = minimum_energy(system)
plot(ŒΩ, œµgs:0.01:2, xlabel=&quot;œµ&quot;, ylabel=&quot;Density of States&quot;)</code></pre><p><img src="../density_of_states.svg" alt/></p><p>This is precisely the red line in Fig. A1. of Ref. <a href="../references/#Villasenor2020">[19]</a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../ClassicalDickeExamples/">¬´ ClassicalDicke</a><a class="docs-footer-nextpage" href="../EnergyShellProjectionsExamples/">EnergyShellProjections ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.3 on <span class="colophon-date" title="Sunday 18 July 2021 19:10">Sunday 18 July 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
